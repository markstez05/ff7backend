"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var definitions = require("../../lib/definitions");

var has = Function.call.bind(Object.prototype.hasOwnProperty);

function joinComparisons(leftArr, right) {
  return leftArr.map(JSON.stringify).join(" === " + right + " || ") + (" === " + right);
}

function addIsHelper(type, aliasKeys, deprecated) {
  var targetType = JSON.stringify(type);
  var aliasSource = "";
  if (aliasKeys) {
    aliasSource = " || " + joinComparisons(aliasKeys, "nodeType");
  }

  var placeholderSource = "";
  var placeholderTypes = [];
  if (definitions.PLACEHOLDERS.includes(type) && has(definitions.FLIPPED_ALIAS_KEYS, type)) {
    placeholderTypes.push(type);
  }
  if (has(definitions.PLACEHOLDERS_FLIPPED_ALIAS, type)) {
    placeholderTypes.push.apply(placeholderTypes, _toConsumableArray(definitions.PLACEHOLDERS_FLIPPED_ALIAS[type]));
  }
  if (placeholderTypes.length > 0) {
    placeholderSource = ' || nodeType === "Placeholder" && (' + joinComparisons(placeholderTypes, "node.expectedNode") + ")";
  }

  return "export function is" + type + "(node: ?Object, opts?: Object): boolean {\n    " + (deprecated || "") + "\n    if (!node) return false;\n\n    const nodeType = node.type;\n    if (nodeType === " + targetType + aliasSource + placeholderSource + ") {\n      if (typeof opts === \"undefined\") {\n        return true;\n      } else {\n        return shallowEqual(node, opts);\n      }\n    }\n\n    return false;\n  }\n  ";
}

module.exports = function generateValidators() {
  var output = "// @flow\n/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport shallowEqual from \"../../utils/shallowEqual\";\n\n";

  Object.keys(definitions.VISITOR_KEYS).forEach(function (type) {
    output += addIsHelper(type);
  });

  Object.keys(definitions.FLIPPED_ALIAS_KEYS).forEach(function (type) {
    output += addIsHelper(type, definitions.FLIPPED_ALIAS_KEYS[type]);
  });

  Object.keys(definitions.DEPRECATED_KEYS).forEach(function (type) {
    var newType = definitions.DEPRECATED_KEYS[type];
    var deprecated = "console.trace(\"The node type " + type + " has been renamed to " + newType + "\");";
    output += addIsHelper(type, null, deprecated);
  });

  return output;
};