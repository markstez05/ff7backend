'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', { value: true });

var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop != null ? conf.binop : null;
  this.updateContext = null;
};

var keywords = new Map();

function createKeyword(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  options.keyword = name;
  var token = new TokenType(name, options);
  keywords.set(name, token);
  return token;
}

function createBinop(name, binop) {
  return new TokenType(name, {
    beforeExpr: beforeExpr,
    binop: binop
  });
}

var types = {
  num: new TokenType("num", {
    startsExpr: startsExpr
  }),
  bigint: new TokenType("bigint", {
    startsExpr: startsExpr
  }),
  regexp: new TokenType("regexp", {
    startsExpr: startsExpr
  }),
  string: new TokenType("string", {
    startsExpr: startsExpr
  }),
  name: new TokenType("name", {
    startsExpr: startsExpr
  }),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceBarL: new TokenType("{|", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", {
    beforeExpr: beforeExpr
  }),
  semi: new TokenType(";", {
    beforeExpr: beforeExpr
  }),
  colon: new TokenType(":", {
    beforeExpr: beforeExpr
  }),
  doubleColon: new TokenType("::", {
    beforeExpr: beforeExpr
  }),
  dot: new TokenType("."),
  question: new TokenType("?", {
    beforeExpr: beforeExpr
  }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", {
    beforeExpr: beforeExpr
  }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", {
    beforeExpr: beforeExpr
  }),
  backQuote: new TokenType("`", {
    startsExpr: startsExpr
  }),
  dollarBraceL: new TokenType("${", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  at: new TokenType("@"),
  hash: new TokenType("#", {
    startsExpr: startsExpr
  }),
  interpreterDirective: new TokenType("#!..."),
  eq: new TokenType("=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  assign: new TokenType("_=", {
    beforeExpr: beforeExpr,
    isAssign: isAssign
  }),
  incDec: new TokenType("++/--", {
    prefix: prefix,
    postfix: postfix,
    startsExpr: startsExpr
  }),
  bang: new TokenType("!", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  tilde: new TokenType("~", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 2),
  logicalAND: createBinop("&&", 3),
  bitwiseOR: createBinop("|", 4),
  bitwiseXOR: createBinop("^", 5),
  bitwiseAND: createBinop("&", 6),
  equality: createBinop("==/!=/===/!==", 7),
  relational: createBinop("</>/<=/>=", 8),
  bitShift: createBinop("<</>>/>>>", 9),
  plusMin: new TokenType("+/-", {
    beforeExpr: beforeExpr,
    binop: 10,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  modulo: new TokenType("%", {
    beforeExpr: beforeExpr,
    binop: 11,
    startsExpr: startsExpr
  }),
  star: createBinop("*", 11),
  slash: createBinop("/", 11),
  exponent: new TokenType("**", {
    beforeExpr: beforeExpr,
    binop: 12,
    rightAssociative: true
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr: beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr: beforeExpr
  }),
  _do: createKeyword("do", {
    isLoop: isLoop,
    beforeExpr: beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr: beforeExpr
  }),
  _finally: createKeyword("finally"),
  _for: createKeyword("for", {
    isLoop: isLoop
  }),
  _function: createKeyword("function", {
    startsExpr: startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr: beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _while: createKeyword("while", {
    isLoop: isLoop
  }),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr: beforeExpr,
    startsExpr: startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr: startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr: startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr: startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr: beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr: startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr: startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr: startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr: startsExpr
  }),
  _in: createKeyword("in", {
    beforeExpr: beforeExpr,
    binop: 8
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr: beforeExpr,
    binop: 8
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr: beforeExpr,
    prefix: prefix,
    startsExpr: startsExpr
  })
};

var SCOPE_OTHER = 0,
    SCOPE_PROGRAM = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS = 256,
    SCOPE_TS_MODULE = 512,
    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
function functionFlags(isAsync, isGenerator) {
  return SCOPE_FUNCTION | (isAsync ? SCOPE_ASYNC : 0) | (isGenerator ? SCOPE_GENERATOR : 0);
}
var BIND_KIND_VALUE = 1,
    BIND_KIND_TYPE = 2,
    BIND_SCOPE_VAR = 4,
    BIND_SCOPE_LEXICAL = 8,
    BIND_SCOPE_FUNCTION = 16,
    BIND_FLAGS_NONE = 64,
    BIND_FLAGS_CLASS = 128,
    BIND_FLAGS_TS_ENUM = 256,
    BIND_FLAGS_TS_CONST_ENUM = 512,
    BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
    BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;

function isSimpleProperty(node) {
  return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estree = function estree(superClass) {
  return function (_superClass) {
    _inherits(_class, _superClass);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'estreeParseRegExpLiteral',
      value: function estreeParseRegExpLiteral(_ref) {
        var pattern = _ref.pattern,
            flags = _ref.flags;

        var regex = null;

        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}

        var node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern: pattern,
          flags: flags
        };
        return node;
      }
    }, {
      key: 'estreeParseLiteral',
      value: function estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
    }, {
      key: 'directiveToStmt',
      value: function directiveToStmt(directive) {
        var directiveLiteral = directive.value;
        var stmt = this.startNodeAt(directive.start, directive.loc.start);
        var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.value;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      }
    }, {
      key: 'initFunction',
      value: function initFunction(node, isAsync) {
        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'initFunction', this).call(this, node, isAsync);
        node.expression = false;
      }
    }, {
      key: 'checkDeclaration',
      value: function checkDeclaration(node) {
        if (isSimpleProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'checkDeclaration', this).call(this, node);
        }
      }
    }, {
      key: 'checkGetterSetterParams',
      value: function checkGetterSetterParams(method) {
        var prop = method;
        var paramCount = prop.kind === "get" ? 0 : 1;
        var start = prop.start;

        if (prop.value.params.length !== paramCount) {
          if (prop.kind === "get") {
            this.raise(start, "getter must not have any formal parameters");
          } else {
            this.raise(start, "setter must have exactly one formal parameter");
          }
        } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
          this.raise(start, "setter function argument must not be a rest parameter");
        }
      }
    }, {
      key: 'checkLVal',
      value: function checkLVal(expr) {
        var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
        var checkClashes = arguments[2];

        var _this2 = this;

        var contextDescription = arguments[3];
        var disallowLetBinding = arguments[4];

        switch (expr.type) {
          case "ObjectPattern":
            expr.properties.forEach(function (prop) {
              _this2.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
            });
            break;

          default:
            _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'checkLVal', this).call(this, expr, bindingType, checkClashes, contextDescription, disallowLetBinding);
        }
      }
    }, {
      key: 'checkDuplicatedProto',
      value: function checkDuplicatedProto(prop, protoRef) {
        if (prop.type === "SpreadElement" || prop.computed || prop.method || prop.shorthand) {
          return;
        }

        var key = prop.key;
        var name = key.type === "Identifier" ? key.name : String(key.value);

        if (name === "__proto__" && prop.kind === "init") {
          if (protoRef.used && !protoRef.start) {
            protoRef.start = key.start;
          }

          protoRef.used = true;
        }
      }
    }, {
      key: 'isStrictBody',
      value: function isStrictBody(node) {
        var isBlockStatement = node.body.type === "BlockStatement";

        if (isBlockStatement && node.body.body.length > 0) {
          for (var _i = 0, _node$body$body = node.body.body; _i < _node$body$body.length; _i++) {
            var directive = _node$body$body[_i];

            if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
              if (directive.expression.value === "use strict") return true;
            } else {
              break;
            }
          }
        }

        return false;
      }
    }, {
      key: 'isValidDirective',
      value: function isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
      }
    }, {
      key: 'stmtToDirective',
      value: function stmtToDirective(stmt) {
        var directive = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'stmtToDirective', this).call(this, stmt);
        var value = stmt.expression.value;
        directive.value.value = value;
        return directive;
      }
    }, {
      key: 'parseBlockBody',
      value: function parseBlockBody(node, allowDirectives, topLevel, end) {
        var _this3 = this;

        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseBlockBody', this).call(this, node, allowDirectives, topLevel, end);
        var directiveStatements = node.directives.map(function (d) {
          return _this3.directiveToStmt(d);
        });
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
    }, {
      key: 'pushClassMethod',
      value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }

        classBody.body.push(method);
      }
    }, {
      key: 'parseExprAtom',
      value: function parseExprAtom(refShorthandDefaultPos) {
        switch (this.state.type) {
          case types.regexp:
            return this.estreeParseRegExpLiteral(this.state.value);

          case types.num:
          case types.string:
            return this.estreeParseLiteral(this.state.value);

          case types._null:
            return this.estreeParseLiteral(null);

          case types._true:
            return this.estreeParseLiteral(true);

          case types._false:
            return this.estreeParseLiteral(false);

          default:
            return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseExprAtom', this).call(this, refShorthandDefaultPos);
        }
      }
    }, {
      key: 'parseLiteral',
      value: function parseLiteral(value, type, startPos, startLoc) {
        var node = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseLiteral', this).call(this, value, type, startPos, startLoc);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
    }, {
      key: 'parseFunctionBody',
      value: function parseFunctionBody(node, allowExpression) {
        var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseFunctionBody', this).call(this, node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
    }, {
      key: 'parseMethod',
      value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
        var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

        var funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseMethod', this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        type = type === "ClassMethod" ? "MethodDefinition" : type;
        return this.finishNode(node, type);
      }
    }, {
      key: 'parseObjectMethod',
      value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
        var node = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseObjectMethod', this).call(this, prop, isGenerator, isAsync, isPattern, containsEsc);

        if (node) {
          node.type = "Property";
          if (node.kind === "method") node.kind = "init";
          node.shorthand = false;
        }

        return node;
      }
    }, {
      key: 'parseObjectProperty',
      value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
        var node = _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseObjectProperty', this).call(this, prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

        if (node) {
          node.kind = "init";
          node.type = "Property";
        }

        return node;
      }
    }, {
      key: 'toAssignable',
      value: function toAssignable(node, isBinding, contextDescription) {
        if (isSimpleProperty(node)) {
          this.toAssignable(node.value, isBinding, contextDescription);
          return node;
        }

        return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'toAssignable', this).call(this, node, isBinding, contextDescription);
      }
    }, {
      key: 'toAssignableObjectExpressionProp',
      value: function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
        if (prop.kind === "get" || prop.kind === "set") {
          throw this.raise(prop.key.start, "Object pattern can't contain getter or setter");
        } else if (prop.method) {
          throw this.raise(prop.key.start, "Object pattern can't contain methods");
        } else {
          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'toAssignableObjectExpressionProp', this).call(this, prop, isBinding, isLast);
        }
      }
    }]);

    return _class;
  }(superClass);
};

var lineBreak = /\r\n?|[\n\u2028\u2029]/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", false),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true),
  functionStatement: new TokContext("function", false)
};

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();

  if (out === types$1.braceStatement && this.curContext().token === "function") {
    out = this.state.context.pop();
  }

  this.state.exprAllowed = !out.isExpr;
};

types.name.updateContext = function (prevType) {
  var allowed = false;

  if (prevType !== types.dot) {
    if (this.state.value === "of" && !this.state.exprAllowed || this.state.value === "yield" && this.scope.inGenerator) {
      allowed = true;
    }
  }

  this.state.exprAllowed = allowed;

  if (this.state.isIterator) {
    this.state.isIterator = false;
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.state.context.push(types$1.functionExpression);
  } else {
    this.state.context.push(types$1.functionStatement);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }

  this.state.exprAllowed = false;
};

var reservedWords = {
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
var isReservedWord = function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
};
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
  return keywords.has(word);
}
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
var nonASCIIidentifierChars = '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F';
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIteratorStart(current, next) {
  return current === 64 && next === 64;
}
function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(state) {
  return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
}

var exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};

function partition(list, test) {
  var list1 = [];
  var list2 = [];

  for (var i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = function flow(superClass) {
  return function (_superClass2) {
    _inherits(_class2, _superClass2);

    function _class2(options, input) {
      _classCallCheck(this, _class2);

      var _this4 = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, options, input));

      _this4.flowPragma = undefined;
      return _this4;
    }

    _createClass(_class2, [{
      key: 'shouldParseTypes',
      value: function shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
    }, {
      key: 'shouldParseEnums',
      value: function shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
    }, {
      key: 'finishToken',
      value: function finishToken(type, val) {
        if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'finishToken', this).call(this, type, val);
      }
    }, {
      key: 'addComment',
      value: function addComment(comment) {
        if (this.flowPragma === undefined) {
          var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

          if (!matches) ;else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'addComment', this).call(this, comment);
      }
    }, {
      key: 'flowParseTypeInitialiser',
      value: function flowParseTypeInitialiser(tok) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types.colon);
        var type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
    }, {
      key: 'flowParsePredicate',
      value: function flowParsePredicate() {
        var node = this.startNode();
        var moduloLoc = this.state.startLoc;
        var moduloPos = this.state.start;
        this.expect(types.modulo);
        var checksLoc = this.state.startLoc;
        this.expectContextual("checks");

        if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
          this.raise(moduloPos, "Spaces between ´%´ and ´checks´ are not allowed here.");
        }

        if (this.eat(types.parenL)) {
          node.value = this.parseExpression();
          this.expect(types.parenR);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
    }, {
      key: 'flowParseTypeAndPredicateInitialiser',
      value: function flowParseTypeAndPredicateInitialiser() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types.colon);
        var type = null;
        var predicate = null;

        if (this.match(types.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;

          if (this.match(types.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }

        return [type, predicate];
      }
    }, {
      key: 'flowParseDeclareClass',
      value: function flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
    }, {
      key: 'flowParseDeclareFunction',
      value: function flowParseDeclareFunction(node) {
        this.next();
        var id = node.id = this.parseIdentifier();
        var typeNode = this.startNode();
        var typeContainer = this.startNode();

        if (this.isRelational("<")) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }

        this.expect(types.parenL);
        var tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        this.expect(types.parenR);

        var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();

        var _flowParseTypeAndPred2 = _slicedToArray(_flowParseTypeAndPred, 2);

        typeNode.returnType = _flowParseTypeAndPred2[0];
        node.predicate = _flowParseTypeAndPred2[1];

        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        return this.finishNode(node, "DeclareFunction");
      }
    }, {
      key: 'flowParseDeclare',
      value: function flowParseDeclare(node, insideModule) {
        if (this.match(types._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual("module")) {
          if (this.match(types.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(this.state.lastTokStart, "`declare module` cannot be used inside another `declare module`");
            }

            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual("type")) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual("opaque")) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual("interface")) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      }
    }, {
      key: 'flowParseDeclareVariable',
      value: function flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
    }, {
      key: 'flowParseDeclareModule',
      value: function flowParseDeclareModule(node) {
        var _this5 = this;

        this.scope.enter(SCOPE_OTHER);

        if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }

        var bodyNode = node.body = this.startNode();
        var body = bodyNode.body = [];
        this.expect(types.braceL);

        while (!this.match(types.braceR)) {
          var _bodyNode = this.startNode();

          if (this.match(types._import)) {
            this.next();

            if (!this.isContextual("type") && !this.match(types._typeof)) {
              this.raise(this.state.lastTokStart, "Imports within a `declare module` body must always be `import type` or `import typeof`");
            }

            this.parseImport(_bodyNode);
          } else {
            this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
            _bodyNode = this.flowParseDeclare(_bodyNode, true);
          }

          body.push(_bodyNode);
        }

        this.scope.exit();
        this.expect(types.braceR);
        this.finishNode(bodyNode, "BlockStatement");
        var kind = null;
        var hasModuleExport = false;
        var errorMessage = "Found both `declare module.exports` and `declare export` in the same module. " + "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
        body.forEach(function (bodyElement) {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              _this5.raise(bodyElement.start, errorMessage);
            }

            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              _this5.raise(bodyElement.start, "Duplicate `declare module.exports` statement");
            }

            if (kind === "ES") _this5.raise(bodyElement.start, errorMessage);
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
    }, {
      key: 'flowParseDeclareExportDeclaration',
      value: function flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types._export);

        if (this.eat(types._default)) {
          if (this.match(types._function) || this.match(types._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }

          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
            var label = this.state.value;
            var suggestion = exportSuggestions[label];
            this.unexpected(this.state.start, '`declare export ' + label + '` is not supported. Use `' + suggestion + '` instead');
          }

          if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
            node = this.parseExport(node);

            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }

            node.type = "Declare" + node.type;
            return node;
          }
        }

        throw this.unexpected();
      }
    }, {
      key: 'flowParseDeclareModuleExports',
      value: function flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual("exports");
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
    }, {
      key: 'flowParseDeclareTypeAlias',
      value: function flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      }
    }, {
      key: 'flowParseDeclareOpaqueType',
      value: function flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      }
    }, {
      key: 'flowParseDeclareInterface',
      value: function flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      }
    }, {
      key: 'flowParseInterfaceish',
      value: function flowParseInterfaceish(node) {
        var isClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.extends = [];
        node.implements = [];
        node.mixins = [];

        if (this.eat(types._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(types.comma));
        }

        if (this.isContextual("mixins")) {
          this.next();

          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        if (this.isContextual("implements")) {
          this.next();

          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
    }, {
      key: 'flowParseInterfaceExtends',
      value: function flowParseInterfaceExtends() {
        var node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        return this.finishNode(node, "InterfaceExtends");
      }
    }, {
      key: 'flowParseInterface',
      value: function flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      }
    }, {
      key: 'checkNotUnderscore',
      value: function checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(this.state.start, "`_` is only allowed as a type argument to call or new");
        }
      }
    }, {
      key: 'checkReservedType',
      value: function checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;

        if (declaration) {
          this.raise(startLoc, 'Cannot overwrite reserved type ' + word);
          return;
        }

        this.raise(startLoc, 'Unexpected reserved type ' + word);
      }
    }, {
      key: 'flowParseRestrictedIdentifier',
      value: function flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      }
    }, {
      key: 'flowParseTypeAlias',
      value: function flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.right = this.flowParseTypeInitialiser(types.eq);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
    }, {
      key: 'flowParseOpaqueType',
      value: function flowParseOpaqueType(node, declare) {
        this.expectContextual("type");
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.supertype = null;

        if (this.match(types.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types.colon);
        }

        node.impltype = null;

        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types.eq);
        }

        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
    }, {
      key: 'flowParseTypeParameter',
      value: function flowParseTypeParameter() {
        var requireDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var nodeStart = this.state.start;
        var node = this.startNode();
        var variance = this.flowParseVariance();
        var ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;

        if (this.match(types.eq)) {
          this.eat(types.eq);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.");
          }
        }

        return this.finishNode(node, "TypeParameter");
      }
    }, {
      key: 'flowParseTypeParameterDeclaration',
      value: function flowParseTypeParameterDeclaration() {
        var oldInType = this.state.inType;
        var node = this.startNode();
        node.params = [];
        this.state.inType = true;

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        var defaultRequired = false;

        do {
          var typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);

          if (typeParameter.default) {
            defaultRequired = true;
          }

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        } while (!this.isRelational(">"));

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
    }, {
      key: 'flowParseTypeParameterInstantiation',
      value: function flowParseTypeParameterInstantiation() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseType());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
    }, {
      key: 'flowParseTypeParameterInstantiationCallOrNew',
      value: function flowParseTypeParameterInstantiationCallOrNew() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
    }, {
      key: 'flowParseInterfaceType',
      value: function flowParseInterfaceType() {
        var node = this.startNode();
        this.expectContextual("interface");
        node.extends = [];

        if (this.eat(types._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
    }, {
      key: 'flowParseObjectPropertyKey',
      value: function flowParseObjectPropertyKey() {
        return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      }
    }, {
      key: 'flowParseObjectTypeIndexer',
      value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;

        if (this.lookahead().type === types.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }

        this.expect(types.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
    }, {
      key: 'flowParseObjectTypeInternalSlot',
      value: function flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types.bracketR);
        this.expect(types.bracketR);

        if (this.isRelational("<") || this.match(types.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;

          if (this.eat(types.question)) {
            node.optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
        }

        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
    }, {
      key: 'flowParseObjectTypeMethodish',
      value: function flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        this.expect(types.parenL);

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam();
        }

        this.expect(types.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
    }, {
      key: 'flowParseObjectTypeCallProperty',
      value: function flowParseObjectTypeCallProperty(node, isStatic) {
        var valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
    }, {
      key: 'flowParseObjectType',
      value: function flowParseObjectType(_ref2) {
        var allowStatic = _ref2.allowStatic,
            allowExact = _ref2.allowExact,
            allowSpread = _ref2.allowSpread,
            allowProto = _ref2.allowProto,
            allowInexact = _ref2.allowInexact;

        var oldInType = this.state.inType;
        this.state.inType = true;
        var nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        var endDelim = void 0;
        var exact = void 0;
        var inexact = false;

        if (allowExact && this.match(types.braceBarL)) {
          this.expect(types.braceBarL);
          endDelim = types.braceBarR;
          exact = true;
        } else {
          this.expect(types.braceL);
          endDelim = types.braceR;
          exact = false;
        }

        nodeStart.exact = exact;

        while (!this.match(endDelim)) {
          var isStatic = false;
          var protoStart = null;
          var inexactStart = null;
          var node = this.startNode();

          if (allowProto && this.isContextual("proto")) {
            var lookahead = this.lookahead();

            if (lookahead.type !== types.colon && lookahead.type !== types.question) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }

          if (allowStatic && this.isContextual("static")) {
            var _lookahead = this.lookahead();

            if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
              this.next();
              isStatic = true;
            }
          }

          var variance = this.flowParseVariance();

          if (this.eat(types.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (this.eat(types.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(types.parenL) || this.isRelational("<")) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            var _allowInexact;

            var kind = "init";

            if (this.isContextual("get") || this.isContextual("set")) {
              var _lookahead2 = this.lookahead();

              if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
                kind = this.state.value;
                this.next();
              }
            }

            var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, (_allowInexact = allowInexact) != null ? _allowInexact : !exact);

            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }

          this.flowObjectTypeSemicolon();

          if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
            this.raise(inexactStart, "Explicit inexact syntax must appear at the end of an inexact object");
          }
        }

        this.expect(endDelim);

        if (allowSpread) {
          nodeStart.inexact = inexact;
        }

        var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
    }, {
      key: 'flowParseObjectTypeProperty',
      value: function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types.ellipsis)) {
          var isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(this.state.lastTokStart, "Explicit inexact syntax cannot appear in class or interface definitions");
            } else if (!allowInexact) {
              this.raise(this.state.lastTokStart, "Explicit inexact syntax cannot appear inside an explicit exact object type");
            }

            if (variance) {
              this.raise(variance.start, "Explicit inexact syntax cannot have variance");
            }

            return null;
          }

          if (!allowSpread) {
            this.raise(this.state.lastTokStart, "Spread operator cannot appear in class or interface definitions");
          }

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.raise(variance.start, "Spread properties cannot have variance");
          }

          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          var optional = false;

          if (this.isRelational("<") || this.match(types.parenL)) {
            node.method = true;

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;

            if (this.eat(types.question)) {
              optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }

          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
    }, {
      key: 'flowCheckGetterSetterParams',
      value: function flowCheckGetterSetterParams(property) {
        var paramCount = property.kind === "get" ? 0 : 1;
        var start = property.start;
        var length = property.value.params.length + (property.value.rest ? 1 : 0);

        if (length !== paramCount) {
          if (property.kind === "get") {
            this.raise(start, "getter must not have any formal parameters");
          } else {
            this.raise(start, "setter must have exactly one formal parameter");
          }
        }

        if (property.kind === "set" && property.value.rest) {
          this.raise(start, "setter function argument must not be a rest parameter");
        }
      }
    }, {
      key: 'flowObjectTypeSemicolon',
      value: function flowObjectTypeSemicolon() {
        if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
          this.unexpected();
        }
      }
    }, {
      key: 'flowParseQualifiedTypeIdentifier',
      value: function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        var node = id || this.flowParseRestrictedIdentifier(true);

        while (this.eat(types.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }

        return node;
      }
    }, {
      key: 'flowParseGenericType',
      value: function flowParseGenericType(startPos, startLoc, id) {
        var node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }

        return this.finishNode(node, "GenericTypeAnnotation");
      }
    }, {
      key: 'flowParseTypeofType',
      value: function flowParseTypeofType() {
        var node = this.startNode();
        this.expect(types._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
    }, {
      key: 'flowParseTupleType',
      value: function flowParseTupleType() {
        var node = this.startNode();
        node.types = [];
        this.expect(types.bracketL);

        while (this.state.pos < this.length && !this.match(types.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types.bracketR)) break;
          this.expect(types.comma);
        }

        this.expect(types.bracketR);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
    }, {
      key: 'flowParseFunctionTypeParam',
      value: function flowParseFunctionTypeParam() {
        var name = null;
        var optional = false;
        var typeAnnotation = null;
        var node = this.startNode();
        var lh = this.lookahead();

        if (lh.type === types.colon || lh.type === types.question) {
          name = this.parseIdentifier();

          if (this.eat(types.question)) {
            optional = true;
          }

          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }

        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
    }, {
      key: 'reinterpretTypeAsFunctionTypeParam',
      value: function reinterpretTypeAsFunctionTypeParam(type) {
        var node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
    }, {
      key: 'flowParseFunctionTypeParams',
      value: function flowParseFunctionTypeParams() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var rest = null;

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          rest = this.flowParseFunctionTypeParam();
        }

        return {
          params: params,
          rest: rest
        };
      }
    }, {
      key: 'flowIdentToTypeAnnotation',
      value: function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");

          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");

          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");

          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");

          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");

          case "string":
            return this.finishNode(node, "StringTypeAnnotation");

          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      }
    }, {
      key: 'flowParsePrimaryType',
      value: function flowParsePrimaryType() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.startNode();
        var tmp = void 0;
        var type = void 0;
        var isGroupedType = false;
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;

        switch (this.state.type) {
          case types.name:
            if (this.isContextual("interface")) {
              return this.flowParseInterfaceType();
            }

            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

          case types.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });

          case types.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });

          case types.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;

          case types.relational:
            if (this.state.value === "<") {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            }

            break;

          case types.parenL:
            this.next();

            if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
              if (this.match(types.name)) {
                var token = this.lookahead().type;
                isGroupedType = token !== types.question && token !== types.colon;
              } else {
                isGroupedType = true;
              }
            }

            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;

              if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
                this.expect(types.parenR);
                return type;
              } else {
                this.eat(types.comma);
              }
            }

            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }

            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");

          case types.string:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

          case types._true:
          case types._false:
            node.value = this.match(types._true);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");

          case types.plusMin:
            if (this.state.value === "-") {
              this.next();

              if (this.match(types.num)) {
                return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
              }

              if (this.match(types.bigint)) {
                return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
              }

              throw this.raise(this.state.start, 'Unexpected token, expected "number" or "bigint"');
            }

            this.unexpected();

          case types.num:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

          case types.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

          case types._void:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");

          case types._null:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");

          case types._this:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");

          case types.star:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");

          default:
            if (this.state.type.keyword === "typeof") {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              var label = this.state.type.label;
              this.next();
              return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'createIdentifier', this).call(this, node, label);
            }

        }

        throw this.unexpected();
      }
    }, {
      key: 'flowParsePostfixType',
      value: function flowParsePostfixType() {
        var startPos = this.state.start,
            startLoc = this.state.startLoc;
        var type = this.flowParsePrimaryType();

        while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(startPos, startLoc);
          node.elementType = type;
          this.expect(types.bracketL);
          this.expect(types.bracketR);
          type = this.finishNode(node, "ArrayTypeAnnotation");
        }

        return type;
      }
    }, {
      key: 'flowParsePrefixType',
      value: function flowParsePrefixType() {
        var node = this.startNode();

        if (this.eat(types.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
    }, {
      key: 'flowParseAnonFunctionWithoutParens',
      value: function flowParseAnonFunctionWithoutParens() {
        var param = this.flowParsePrefixType();

        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
          var node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        return param;
      }
    }, {
      key: 'flowParseIntersectionType',
      value: function flowParseIntersectionType() {
        var node = this.startNode();
        this.eat(types.bitwiseAND);
        var type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];

        while (this.eat(types.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
    }, {
      key: 'flowParseUnionType',
      value: function flowParseUnionType() {
        var node = this.startNode();
        this.eat(types.bitwiseOR);
        var type = this.flowParseIntersectionType();
        node.types = [type];

        while (this.eat(types.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
    }, {
      key: 'flowParseType',
      value: function flowParseType() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        var type = this.flowParseUnionType();
        this.state.inType = oldInType;
        this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
        return type;
      }
    }, {
      key: 'flowParseTypeOrImplicitInstantiation',
      value: function flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types.name && this.state.value === "_") {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
    }, {
      key: 'flowParseTypeAnnotation',
      value: function flowParseTypeAnnotation() {
        var node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
    }, {
      key: 'flowParseTypeAnnotatableIdentifier',
      value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

        if (this.match(types.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }

        return ident;
      }
    }, {
      key: 'typeCastToParameter',
      value: function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      }
    }, {
      key: 'flowParseVariance',
      value: function flowParseVariance() {
        var variance = null;

        if (this.match(types.plusMin)) {
          variance = this.startNode();

          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }

          this.next();
          this.finishNode(variance, "Variance");
        }

        return variance;
      }
    }, {
      key: 'parseFunctionBody',
      value: function parseFunctionBody(node, allowExpressionBody) {
        var _this6 = this;

        var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, function () {
            return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseFunctionBody', _this6).call(_this6, node, true, isMethod);
          });
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseFunctionBody', this).call(this, node, false, isMethod);
      }
    }, {
      key: 'parseFunctionBodyAndFinish',
      value: function parseFunctionBodyAndFinish(node, type) {
        var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.match(types.colon)) {
          var typeNode = this.startNode();

          var _flowParseTypeAndPred3 = this.flowParseTypeAndPredicateInitialiser();

          var _flowParseTypeAndPred4 = _slicedToArray(_flowParseTypeAndPred3, 2);

          typeNode.typeAnnotation = _flowParseTypeAndPred4[0];
          node.predicate = _flowParseTypeAndPred4[1];

          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseFunctionBodyAndFinish', this).call(this, node, type, isMethod);
      }
    }, {
      key: 'parseStatement',
      value: function parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
          var node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          var _node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(_node);
        } else {
          var stmt = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseStatement', this).call(this, context, topLevel);

          if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }

          return stmt;
        }
      }
    }, {
      key: 'parseExpressionStatement',
      value: function parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseExpressionStatement', this).call(this, node, expr);
      }
    }, {
      key: 'shouldParseExportDeclaration',
      value: function shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'shouldParseExportDeclaration', this).call(this);
      }
    }, {
      key: 'isExportDefaultSpecifier',
      value: function isExportDefaultSpecifier() {
        if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
          return false;
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'isExportDefaultSpecifier', this).call(this);
      }
    }, {
      key: 'parseExportDefaultExpression',
      value: function parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          var node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseExportDefaultExpression', this).call(this);
      }
    }, {
      key: 'parseConditional',
      value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        var _this7 = this;

        if (!this.match(types.question)) return expr;

        if (refNeedsArrowPos) {
          var result = this.tryParse(function () {
            return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseConditional', _this7).call(_this7, expr, noIn, startPos, startLoc);
          });

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }

        this.expect(types.question);
        var state = this.state.clone();
        var originalNoArrowAt = this.state.noArrowAt;
        var node = this.startNodeAt(startPos, startLoc);

        var _tryParseConditionalC = this.tryParseConditionalConsequent(),
            consequent = _tryParseConditionalC.consequent,
            failed = _tryParseConditionalC.failed;

        var _getArrowLikeExpressi = this.getArrowLikeExpressions(consequent),
            _getArrowLikeExpressi2 = _slicedToArray(_getArrowLikeExpressi, 2),
            valid = _getArrowLikeExpressi2[0],
            invalid = _getArrowLikeExpressi2[1];

        if (failed || invalid.length > 0) {
          var noArrowAt = [].concat(_toConsumableArray(originalNoArrowAt));

          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;

            for (var i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }

            var _tryParseConditionalC2 = this.tryParseConditionalConsequent();

            consequent = _tryParseConditionalC2.consequent;
            failed = _tryParseConditionalC2.failed;

            var _getArrowLikeExpressi3 = this.getArrowLikeExpressions(consequent);

            var _getArrowLikeExpressi4 = _slicedToArray(_getArrowLikeExpressi3, 2);

            valid = _getArrowLikeExpressi4[0];
            invalid = _getArrowLikeExpressi4[1];
          }

          if (failed && valid.length > 1) {
            this.raise(state.start, "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.");
          }

          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);

            var _tryParseConditionalC3 = this.tryParseConditionalConsequent();

            consequent = _tryParseConditionalC3.consequent;
            failed = _tryParseConditionalC3.failed;
          }
        }

        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
          return _this7.parseMaybeAssign(noIn, undefined, undefined, undefined);
        });
        return this.finishNode(node, "ConditionalExpression");
      }
    }, {
      key: 'tryParseConditionalConsequent',
      value: function tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        var consequent = this.parseMaybeAssign();
        var failed = !this.match(types.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent: consequent,
          failed: failed
        };
      }
    }, {
      key: 'getArrowLikeExpressions',
      value: function getArrowLikeExpressions(node, disallowInvalid) {
        var _this8 = this;

        var stack = [node];
        var arrows = [];

        while (stack.length !== 0) {
          var _node2 = stack.pop();

          if (_node2.type === "ArrowFunctionExpression") {
            if (_node2.typeParameters || !_node2.returnType) {
              this.finishArrowValidation(_node2);
            } else {
              arrows.push(_node2);
            }

            stack.push(_node2.body);
          } else if (_node2.type === "ConditionalExpression") {
            stack.push(_node2.consequent);
            stack.push(_node2.alternate);
          }
        }

        if (disallowInvalid) {
          arrows.forEach(function (node) {
            return _this8.finishArrowValidation(node);
          });
          return [arrows, []];
        }

        return partition(arrows, function (node) {
          return node.params.every(function (param) {
            return _this8.isAssignable(param, true);
          });
        });
      }
    }, {
      key: 'finishArrowValidation',
      value: function finishArrowValidation(node) {
        var _node$extra;

        this.toAssignableList(node.params, true, "arrow function parameters", (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);
        this.scope.enter(functionFlags(false, false) | SCOPE_ARROW);
        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'checkParams', this).call(this, node, false, true);
        this.scope.exit();
      }
    }, {
      key: 'forwardNoArrowParamsConversionAt',
      value: function forwardNoArrowParamsConversionAt(node, parse) {
        var result = void 0;

        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }

        return result;
      }
    }, {
      key: 'parseParenItem',
      value: function parseParenItem(node, startPos, startLoc) {
        node = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseParenItem', this).call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }

        return node;
      }
    }, {
      key: 'assertModuleNodeAllowed',
      value: function assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'assertModuleNodeAllowed', this).call(this, node);
      }
    }, {
      key: 'parseExport',
      value: function parseExport(node) {
        var decl = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseExport', this).call(this, node);

        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }

        return decl;
      }
    }, {
      key: 'parseExportDeclaration',
      value: function parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();

          if (this.match(types.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("opaque")) {
          node.exportKind = "type";
          var _declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(_declarationNode, false);
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";
          var _declarationNode2 = this.startNode();
          this.next();
          return this.flowParseInterface(_declarationNode2);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";
          var _declarationNode3 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(_declarationNode3);
        } else {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseExportDeclaration', this).call(this, node);
        }
      }
    }, {
      key: 'eatExportStar',
      value: function eatExportStar(node) {
        if (_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'eatExportStar', this).apply(this, arguments)) return true;

        if (this.isContextual("type") && this.lookahead().type === types.star) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }

        return false;
      }
    }, {
      key: 'maybeParseExportNamespaceSpecifier',
      value: function maybeParseExportNamespaceSpecifier(node) {
        var pos = this.state.start;
        var hasNamespace = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'maybeParseExportNamespaceSpecifier', this).call(this, node);

        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(pos);
        }

        return hasNamespace;
      }
    }, {
      key: 'parseClassId',
      value: function parseClassId(node, isStatement, optionalId) {
        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseClassId', this).call(this, node, isStatement, optionalId);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
    }, {
      key: 'getTokenFromCode',
      value: function getTokenFromCode(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 123 && next === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.isIterator = true;
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'readWord', this).call(this);
        } else {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'getTokenFromCode', this).call(this, code);
        }
      }
    }, {
      key: 'isAssignable',
      value: function isAssignable(node, isBinding) {
        var _this9 = this;

        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            return true;

          case "ObjectExpression":
            {
              var _last = node.properties.length - 1;
              return node.properties.every(function (prop, i) {
                return prop.type !== "ObjectMethod" && (i === _last || prop.type === "SpreadElement") && _this9.isAssignable(prop);
              });
            }

          case "ObjectProperty":
            return this.isAssignable(node.value);

          case "SpreadElement":
            return this.isAssignable(node.argument);

          case "ArrayExpression":
            return node.elements.every(function (element) {
              return _this9.isAssignable(element);
            });

          case "AssignmentExpression":
            return node.operator === "=";

          case "ParenthesizedExpression":
          case "TypeCastExpression":
            return this.isAssignable(node.expression);

          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;

          default:
            return false;
        }
      }
    }, {
      key: 'toAssignable',
      value: function toAssignable(node, isBinding, contextDescription) {
        if (node.type === "TypeCastExpression") {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'toAssignable', this).call(this, this.typeCastToParameter(node), isBinding, contextDescription);
        } else {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'toAssignable', this).call(this, node, isBinding, contextDescription);
        }
      }
    }, {
      key: 'toAssignableList',
      value: function toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'toAssignableList', this).call(this, exprList, isBinding, contextDescription, trailingCommaPos);
      }
    }, {
      key: 'toReferencedList',
      value: function toReferencedList(exprList, isParenthesizedExpr) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(expr.typeAnnotation.start, "The type cast expression is expected to be wrapped with parenthesis");
          }
        }

        return exprList;
      }
    }, {
      key: 'checkLVal',
      value: function checkLVal(expr) {
        var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
        var checkClashes = arguments[2];
        var contextDescription = arguments[3];

        if (expr.type !== "TypeCastExpression") {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'checkLVal', this).call(this, expr, bindingType, checkClashes, contextDescription);
        }
      }
    }, {
      key: 'parseClassProperty',
      value: function parseClassProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseClassProperty', this).call(this, node);
      }
    }, {
      key: 'parseClassPrivateProperty',
      value: function parseClassPrivateProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseClassPrivateProperty', this).call(this, node);
      }
    }, {
      key: 'isClassMethod',
      value: function isClassMethod() {
        return this.isRelational("<") || _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'isClassMethod', this).call(this);
      }
    }, {
      key: 'isClassProperty',
      value: function isClassProperty() {
        return this.match(types.colon) || _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'isClassProperty', this).call(this);
      }
    }, {
      key: 'isNonstaticConstructor',
      value: function isNonstaticConstructor(method) {
        return !this.match(types.colon) && _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'isNonstaticConstructor', this).call(this, method);
      }
    }, {
      key: 'pushClassMethod',
      value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'pushClassMethod', this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
    }, {
      key: 'pushClassPrivateMethod',
      value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'pushClassPrivateMethod', this).call(this, classBody, method, isGenerator, isAsync);
      }
    }, {
      key: 'parseClassSuper',
      value: function parseClassSuper(node) {
        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseClassSuper', this).call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }

        if (this.isContextual("implements")) {
          this.next();
          var implemented = node.implements = [];

          do {
            var _node3 = this.startNode();
            _node3.id = this.flowParseRestrictedIdentifier(true);

            if (this.isRelational("<")) {
              _node3.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node3.typeParameters = null;
            }

            implemented.push(this.finishNode(_node3, "ClassImplements"));
          } while (this.eat(types.comma));
        }
      }
    }, {
      key: 'parsePropertyName',
      value: function parsePropertyName(node) {
        var variance = this.flowParseVariance();
        var key = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parsePropertyName', this).call(this, node);
        node.variance = variance;
        return key;
      }
    }, {
      key: 'parseObjPropValue',
      value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }

        delete prop.variance;
        var typeParameters = void 0;

        if (this.isRelational("<")) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types.parenL)) this.unexpected();
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseObjPropValue', this).call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);

        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      }
    }, {
      key: 'parseAssignableListItemTypes',
      value: function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
          }

          param.optional = true;
        }

        if (this.match(types.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        }

        this.resetEndLocation(param);
        return param;
      }
    }, {
      key: 'parseMaybeDefault',
      value: function parseMaybeDefault(startPos, startLoc, left) {
        var node = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseMaybeDefault', this).call(this, startPos, startLoc, left);

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
        }

        return node;
      }
    }, {
      key: 'shouldParseDefaultImport',
      value: function shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'shouldParseDefaultImport', this).call(this, node);
        }

        return isMaybeDefaultImport(this.state);
      }
    }, {
      key: 'parseImportSpecifierLocal',
      value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
        node.specifiers.push(this.finishNode(specifier, type));
      }
    }, {
      key: 'maybeParseDefaultImportSpecifier',
      value: function maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        var kind = null;

        if (this.match(types._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }

        if (kind) {
          var lh = this.lookahead();

          if (kind === "type" && lh.type === types.star) {
            this.unexpected(lh.start);
          }

          if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
            this.next();
            node.importKind = kind;
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'maybeParseDefaultImportSpecifier', this).call(this, node);
      }
    }, {
      key: 'parseImportSpecifier',
      value: function parseImportSpecifier(node) {
        var specifier = this.startNode();
        var firstIdentLoc = this.state.start;
        var firstIdent = this.parseIdentifier(true);
        var specifierTypeKind = null;

        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }

        var isBinding = false;

        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          var as_ident = this.parseIdentifier(true);

          if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = as_ident.__clone();
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;

          if (this.eatContextual("as")) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = specifier.imported.__clone();
          }
        } else {
          isBinding = true;
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = specifier.imported.__clone();
        }

        var nodeIsTypeImport = hasTypeImportKind(node);
        var specifierIsTypeImport = hasTypeImportKind(specifier);

        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(firstIdentLoc, "The `type` and `typeof` keywords on named imports can only be used on regular " + "`import` statements. It cannot be used with `import type` or `import typeof` statements");
        }

        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.start, true);
        }

        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.start, true, true);
        }

        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      }
    }, {
      key: 'parseFunctionParams',
      value: function parseFunctionParams(node, allowModifiers) {
        var kind = node.kind;

        if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseFunctionParams', this).call(this, node, allowModifiers);
      }
    }, {
      key: 'parseVarId',
      value: function parseVarId(decl, kind) {
        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseVarId', this).call(this, decl, kind);

        if (this.match(types.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
    }, {
      key: 'parseAsyncArrowFromCallExpression',
      value: function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseAsyncArrowFromCallExpression', this).call(this, node, call);
      }
    }, {
      key: 'shouldParseAsyncArrow',
      value: function shouldParseAsyncArrow() {
        return this.match(types.colon) || _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'shouldParseAsyncArrow', this).call(this);
      }
    }, {
      key: 'parseMaybeAssign',
      value: function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
        var _this10 = this;

        var state = null;
        var jsx = void 0;

        if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseMaybeAssign', _this10).call(_this10, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;


          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (jsx && jsx.error || this.isRelational("<")) {
          state = state || this.state.clone();
          var typeParameters = void 0;
          var arrow = this.tryParse(function () {
            typeParameters = _this10.flowParseTypeParameterDeclaration();
            var arrowExpression = _this10.forwardNoArrowParamsConversionAt(typeParameters, function () {
              return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseMaybeAssign', _this10).call(_this10, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
            });
            arrowExpression.typeParameters = typeParameters;
            _this10.resetStartLocationFromNode(arrowExpression, typeParameters);
            return arrowExpression;
          }, state);
          var arrowExpression = arrow.node && arrow.node.type === "ArrowFunctionExpression" ? arrow.node : null;
          if (!arrow.error && arrowExpression) return arrowExpression;

          if (jsx && jsx.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }

          if (jsx && jsx.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseMaybeAssign', this).call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
      }
    }, {
      key: 'parseArrow',
      value: function parseArrow(node) {
        var _this11 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function () {
            var oldNoAnonFunctionType = _this11.state.noAnonFunctionType;
            _this11.state.noAnonFunctionType = true;
            var typeNode = _this11.startNode();

            var _flowParseTypeAndPred5 = _this11.flowParseTypeAndPredicateInitialiser();

            var _flowParseTypeAndPred6 = _slicedToArray(_flowParseTypeAndPred5, 2);

            typeNode.typeAnnotation = _flowParseTypeAndPred6[0];
            node.predicate = _flowParseTypeAndPred6[1];

            _this11.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_this11.canInsertSemicolon()) _this11.unexpected();
            if (!_this11.match(types.arrow)) _this11.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseArrow', this).call(this, node);
      }
    }, {
      key: 'shouldParseArrow',
      value: function shouldParseArrow() {
        return this.match(types.colon) || _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'shouldParseArrow', this).call(this);
      }
    }, {
      key: 'setArrowFunctionParameters',
      value: function setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'setArrowFunctionParameters', this).call(this, node, params);
        }
      }
    }, {
      key: 'checkParams',
      value: function checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'checkParams', this).apply(this, arguments);
      }
    }, {
      key: 'parseParenAndDistinguishExpression',
      value: function parseParenAndDistinguishExpression(canBeArrow) {
        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseParenAndDistinguishExpression', this).call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
    }, {
      key: 'parseSubscripts',
      value: function parseSubscripts(base, startPos, startLoc, noCalls) {
        var _this12 = this;

        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
          var state = this.state.clone();
          var arrow = this.tryParse(function (abort) {
            return _this12.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          var result = this.tryParse(function () {
            return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseSubscripts', _this12).call(_this12, base, startPos, startLoc, noCalls);
          }, state);
          if (result.node && !result.error) return result.node;

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (result.node) {
            this.state = result.failState;
            return result.node;
          }

          throw arrow.error || result.error;
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseSubscripts', this).call(this, base, startPos, startLoc, noCalls);
      }
    }, {
      key: 'parseSubscript',
      value: function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        var _this13 = this;

        if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
          this.expectPlugin("optionalChaining");
          subscriptState.optionalChainMember = true;

          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }

          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types.parenL);
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          var _node4 = this.startNodeAt(startPos, startLoc);
          _node4.callee = base;
          var result = this.tryParse(function () {
            _node4.typeArguments = _this13.flowParseTypeParameterInstantiationCallOrNew();
            _this13.expect(types.parenL);
            _node4.arguments = _this13.parseCallExpressionArguments(types.parenR, false);
            if (subscriptState.optionalChainMember) _node4.optional = false;
            return _this13.finishCallExpression(_node4, subscriptState.optionalChainMember);
          });

          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }

        return _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseSubscript', this).call(this, base, startPos, startLoc, noCalls, subscriptState);
      }
    }, {
      key: 'parseNewArguments',
      value: function parseNewArguments(node) {
        var _this14 = this;

        var targs = null;

        if (this.shouldParseTypes() && this.isRelational("<")) {
          targs = this.tryParse(function () {
            return _this14.flowParseTypeParameterInstantiationCallOrNew();
          }).node;
        }

        node.typeArguments = targs;
        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseNewArguments', this).call(this, node);
      }
    }, {
      key: 'parseAsyncArrowWithTypeParameters',
      value: function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node)) return;
        return this.parseArrowExpression(node, undefined, true);
      }
    }, {
      key: 'readToken_mult_modulo',
      value: function readToken_mult_modulo(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'readToken_mult_modulo', this).call(this, code);
      }
    }, {
      key: 'readToken_pipe_amp',
      value: function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 124 && next === 125) {
          this.finishOp(types.braceBarR, 2);
          return;
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'readToken_pipe_amp', this).call(this, code);
      }
    }, {
      key: 'parseTopLevel',
      value: function parseTopLevel(file, program) {
        var fileNode = _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'parseTopLevel', this).call(this, file, program);

        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, "Unterminated flow-comment");
        }

        return fileNode;
      }
    }, {
      key: 'skipBlockComment',
      value: function skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, "Cannot have a flow comment inside another flow comment");
          }

          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }

        if (this.state.hasFlowComment) {
          var end = this.input.indexOf("*-/", this.state.pos += 2);

          if (end === -1) {
            throw this.raise(this.state.pos - 2, "Unterminated comment");
          }

          this.state.pos = end + 3;
          return;
        }

        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), 'skipBlockComment', this).call(this);
      }
    }, {
      key: 'skipFlowComment',
      value: function skipFlowComment() {
        var pos = this.state.pos;

        var shiftToFirstNonWhiteSpace = 2;

        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }

        var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }

        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }

        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }

        return false;
      }
    }, {
      key: 'hasFlowCommentCompletion',
      value: function hasFlowCommentCompletion() {
        var end = this.input.indexOf("*/", this.state.pos);

        if (end === -1) {
          throw this.raise(this.state.pos, "Unterminated comment");
        }
      }
    }, {
      key: 'flowEnumErrorBooleanMemberNotInitialized',
      value: function flowEnumErrorBooleanMemberNotInitialized(pos, _ref3) {
        var enumName = _ref3.enumName,
            memberName = _ref3.memberName;

        this.raise(pos, 'Boolean enum members need to be initialized. Use either `' + memberName + ' = true,` ' + ('or `' + memberName + ' = false,` in enum `' + enumName + '`.'));
      }
    }, {
      key: 'flowEnumErrorInvalidMemberName',
      value: function flowEnumErrorInvalidMemberName(pos, _ref4) {
        var enumName = _ref4.enumName,
            memberName = _ref4.memberName;

        var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, 'Enum member names cannot start with lowercase \'a\' through \'z\'. Instead of using ' + ('`' + memberName + '`, consider using `' + suggestion + '`, in enum `' + enumName + '`.'));
      }
    }, {
      key: 'flowEnumErrorDuplicateMemberName',
      value: function flowEnumErrorDuplicateMemberName(pos, _ref5) {
        var enumName = _ref5.enumName,
            memberName = _ref5.memberName;

        this.raise(pos, 'Enum member names need to be unique, but the name `' + memberName + '` has already been used ' + ('before in enum `' + enumName + '`.'));
      }
    }, {
      key: 'flowEnumErrorInconsistentMemberValues',
      value: function flowEnumErrorInconsistentMemberValues(pos, _ref6) {
        var enumName = _ref6.enumName;

        this.raise(pos, 'Enum `' + enumName + '` has inconsistent member initializers. Either use no initializers, or ' + 'consistently use literals (either booleans, numbers, or strings) for all member initializers.');
      }
    }, {
      key: 'flowEnumErrorInvalidExplicitType',
      value: function flowEnumErrorInvalidExplicitType(pos, _ref7) {
        var enumName = _ref7.enumName,
            suppliedType = _ref7.suppliedType;

        var suggestion = 'Use one of `boolean`, `number`, `string`, or `symbol` in ' + ('enum `' + enumName + '`.');
        var message = suppliedType === null ? 'Supplied enum type is not valid. ' + suggestion : 'Enum type `' + suppliedType + '` is not valid. ' + suggestion;
        return this.raise(pos, message);
      }
    }, {
      key: 'flowEnumErrorInvalidMemberInitializer',
      value: function flowEnumErrorInvalidMemberInitializer(pos, _ref8) {
        var enumName = _ref8.enumName,
            explicitType = _ref8.explicitType,
            memberName = _ref8.memberName;

        var message = null;

        switch (explicitType) {
          case "boolean":
          case "number":
          case "string":
            message = 'Enum `' + enumName + '` has type `' + explicitType + '`, so the initializer of ' + ('`' + memberName + '` needs to be a ' + explicitType + ' literal.');
            break;

          case "symbol":
            message = 'Symbol enum members cannot be initialized. Use `' + memberName + ',` in ' + ('enum `' + enumName + '`.');
            break;

          default:
            message = 'The enum member initializer for `' + memberName + '` needs to be a literal (either ' + ('a boolean, number, or string) in enum `' + enumName + '`.');
        }

        return this.raise(pos, message);
      }
    }, {
      key: 'flowEnumErrorNumberMemberNotInitialized',
      value: function flowEnumErrorNumberMemberNotInitialized(pos, _ref9) {
        var enumName = _ref9.enumName,
            memberName = _ref9.memberName;

        this.raise(pos, 'Number enum members need to be initialized, e.g. `' + memberName + ' = 1` in enum `' + enumName + '`.');
      }
    }, {
      key: 'flowEnumErrorStringMemberInconsistentlyInitailized',
      value: function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref10) {
        var enumName = _ref10.enumName;

        this.raise(pos, 'String enum members need to consistently either all use initializers, or use no initializers, ' + ('in enum `' + enumName + '`.'));
      }
    }, {
      key: 'flowEnumMemberInit',
      value: function flowEnumMemberInit() {
        var _this15 = this;

        var startPos = this.state.start;

        var endOfInit = function endOfInit() {
          return _this15.match(types.comma) || _this15.match(types.braceR);
        };

        switch (this.state.type) {
          case types.num:
            {
              var _literal = this.parseLiteral(this.state.value, "NumericLiteral");

              if (endOfInit()) {
                return {
                  type: "number",
                  pos: _literal.start,
                  value: _literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types.string:
            {
              var _literal2 = this.parseLiteral(this.state.value, "StringLiteral");

              if (endOfInit()) {
                return {
                  type: "string",
                  pos: _literal2.start,
                  value: _literal2
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types._true:
          case types._false:
            {
              var _literal3 = this.parseBooleanLiteral();

              if (endOfInit()) {
                return {
                  type: "boolean",
                  pos: _literal3.start,
                  value: _literal3
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          default:
            return {
              type: "invalid",
              pos: startPos
            };
        }
      }
    }, {
      key: 'flowEnumMemberRaw',
      value: function flowEnumMemberRaw() {
        var pos = this.state.start;
        var id = this.parseIdentifier(true);
        var init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
          type: "none",
          pos: pos
        };
        return {
          id: id,
          init: init
        };
      }
    }, {
      key: 'flowEnumCheckExplicitTypeMismatch',
      value: function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        var explicitType = context.explicitType;


        if (explicitType === null) {
          return;
        }

        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      }
    }, {
      key: 'flowEnumMembers',
      value: function flowEnumMembers(_ref11) {
        var enumName = _ref11.enumName,
            explicitType = _ref11.explicitType;

        var seenNames = new Set();
        var members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };

        while (!this.match(types.braceR)) {
          var memberNode = this.startNode();

          var _flowEnumMemberRaw = this.flowEnumMemberRaw(),
              id = _flowEnumMemberRaw.id,
              init = _flowEnumMemberRaw.init;

          var memberName = id.name;

          if (memberName === "") {
            continue;
          }

          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          seenNames.add(memberName);
          var context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          memberNode.id = id;

          switch (init.type) {
            case "boolean":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }

            case "number":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }

            case "string":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }

            case "invalid":
              {
                throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
              }

            case "none":
              {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                    break;

                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                    break;

                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
          }

          if (!this.match(types.braceR)) {
            this.expect(types.comma);
          }
        }

        return members;
      }
    }, {
      key: 'flowEnumStringMembers',
      value: function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref12) {
        var enumName = _ref12.enumName;

        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (var _i = 0; _i < initializedMembers.length; _i++) {
            var member = initializedMembers[_i];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName: enumName
            });
          }

          return defaultedMembers;
        } else {
          for (var _i2 = 0; _i2 < defaultedMembers.length; _i2++) {
            var _member = defaultedMembers[_i2];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
              enumName: enumName
            });
          }

          return initializedMembers;
        }
      }
    }, {
      key: 'flowEnumParseExplicitType',
      value: function flowEnumParseExplicitType(_ref13) {
        var enumName = _ref13.enumName;

        if (this.eatContextual("of")) {
          if (!this.match(types.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: null
            });
          }

          var value = this.state.value;

          this.next();

          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: value
            });
          }

          return value;
        }

        return null;
      }
    }, {
      key: 'flowEnumBody',
      value: function flowEnumBody(node, _ref14) {
        var _this16 = this;

        var enumName = _ref14.enumName,
            nameLoc = _ref14.nameLoc;

        var explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(types.braceL);
        var members = this.flowEnumMembers({
          enumName: enumName,
          explicitType: explicitType
        });

        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumBooleanBody");

          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumNumberBody");

          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName: enumName
            });
            this.expect(types.braceR);
            return this.finishNode(node, "EnumStringBody");

          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumSymbolBody");

          default:
            {
              var empty = function empty() {
                node.members = [];
                _this16.expect(types.braceR);
                return _this16.finishNode(node, "EnumStringBody");
              };

              node.explicitType = false;
              var boolsLen = members.booleanMembers.length;
              var numsLen = members.numberMembers.length;
              var strsLen = members.stringMembers.length;
              var defaultedLen = members.defaultedMembers.length;

              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName: enumName
                });
                this.expect(types.braceR);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (var _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {
                  var member = _members$defaultedMem[_i3];
                  this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                    enumName: enumName,
                    memberName: member.id.name
                  });
                }

                node.members = members.booleanMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (var _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {
                  var _member2 = _members$defaultedMem2[_i4];
                  this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                    enumName: enumName,
                    memberName: _member2.id.name
                  });
                }

                node.members = members.numberMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                  enumName: enumName
                });
                return empty();
              }
            }
        }
      }
    }, {
      key: 'flowParseEnumDeclaration',
      value: function flowParseEnumDeclaration(node) {
        var id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        });
        return this.finishNode(node, "EnumDeclaration");
      }
    }]);

    return _class2;
  }(superClass);
};

var entities = {
  quot: '"',
  amp: "&",
  apos: '\'',
  lt: "<",
  gt: ">",
  nbsp: '\xA0',
  iexcl: '\xA1',
  cent: '\xA2',
  pound: '\xA3',
  curren: '\xA4',
  yen: '\xA5',
  brvbar: '\xA6',
  sect: '\xA7',
  uml: '\xA8',
  copy: '\xA9',
  ordf: '\xAA',
  laquo: '\xAB',
  not: '\xAC',
  shy: '\xAD',
  reg: '\xAE',
  macr: '\xAF',
  deg: '\xB0',
  plusmn: '\xB1',
  sup2: '\xB2',
  sup3: '\xB3',
  acute: '\xB4',
  micro: '\xB5',
  para: '\xB6',
  middot: '\xB7',
  cedil: '\xB8',
  sup1: '\xB9',
  ordm: '\xBA',
  raquo: '\xBB',
  frac14: '\xBC',
  frac12: '\xBD',
  frac34: '\xBE',
  iquest: '\xBF',
  Agrave: '\xC0',
  Aacute: '\xC1',
  Acirc: '\xC2',
  Atilde: '\xC3',
  Auml: '\xC4',
  Aring: '\xC5',
  AElig: '\xC6',
  Ccedil: '\xC7',
  Egrave: '\xC8',
  Eacute: '\xC9',
  Ecirc: '\xCA',
  Euml: '\xCB',
  Igrave: '\xCC',
  Iacute: '\xCD',
  Icirc: '\xCE',
  Iuml: '\xCF',
  ETH: '\xD0',
  Ntilde: '\xD1',
  Ograve: '\xD2',
  Oacute: '\xD3',
  Ocirc: '\xD4',
  Otilde: '\xD5',
  Ouml: '\xD6',
  times: '\xD7',
  Oslash: '\xD8',
  Ugrave: '\xD9',
  Uacute: '\xDA',
  Ucirc: '\xDB',
  Uuml: '\xDC',
  Yacute: '\xDD',
  THORN: '\xDE',
  szlig: '\xDF',
  agrave: '\xE0',
  aacute: '\xE1',
  acirc: '\xE2',
  atilde: '\xE3',
  auml: '\xE4',
  aring: '\xE5',
  aelig: '\xE6',
  ccedil: '\xE7',
  egrave: '\xE8',
  eacute: '\xE9',
  ecirc: '\xEA',
  euml: '\xEB',
  igrave: '\xEC',
  iacute: '\xED',
  icirc: '\xEE',
  iuml: '\xEF',
  eth: '\xF0',
  ntilde: '\xF1',
  ograve: '\xF2',
  oacute: '\xF3',
  ocirc: '\xF4',
  otilde: '\xF5',
  ouml: '\xF6',
  divide: '\xF7',
  oslash: '\xF8',
  ugrave: '\xF9',
  uacute: '\xFA',
  ucirc: '\xFB',
  uuml: '\xFC',
  yacute: '\xFD',
  thorn: '\xFE',
  yuml: '\xFF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  int: '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};

var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;
types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", {
  beforeExpr: true
});
types.jsxTagStart = new TokenType("jsxTagStart", {
  startsExpr: true
});
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr);
  this.state.context.push(types$1.j_oTag);
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();

  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = function jsx(superClass) {
  return function (_superClass3) {
    _inherits(_class3, _superClass3);

    function _class3() {
      _classCallCheck(this, _class3);

      return _possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).apply(this, arguments));
    }

    _createClass(_class3, [{
      key: 'jsxReadToken',
      value: function jsxReadToken() {
        var out = "";
        var chunkStart = this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, "Unterminated JSX contents");
          }

          var ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types.jsxTagStart);
                }

                return _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'getTokenFromCode', this).call(this, ch);
              }

              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types.jsxText, out);

            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;

            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }

          }
        }
      }
    }, {
      key: 'jsxReadNewLine',
      value: function jsxReadNewLine(normalizeCRLF) {
        var ch = this.input.charCodeAt(this.state.pos);
        var out = void 0;
        ++this.state.pos;

        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
    }, {
      key: 'jsxReadString',
      value: function jsxReadString(quote) {
        var out = "";
        var chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, "Unterminated string constant");
          }

          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types.string, out);
      }
    }, {
      key: 'jsxReadEntity',
      value: function jsxReadEntity() {
        var str = "";
        var count = 0;
        var entity = void 0;
        var ch = this.input[this.state.pos];
        var startPos = ++this.state.pos;

        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];

          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);

                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);

                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }

            break;
          }

          str += ch;
        }

        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }

        return entity;
      }
    }, {
      key: 'jsxReadWord',
      value: function jsxReadWord() {
        var ch = void 0;
        var start = this.state.pos;

        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);

        return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
      }
    }, {
      key: 'jsxParseIdentifier',
      value: function jsxParseIdentifier() {
        var node = this.startNode();

        if (this.match(types.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }

        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
    }, {
      key: 'jsxParseNamespacedName',
      value: function jsxParseNamespacedName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var name = this.jsxParseIdentifier();
        if (!this.eat(types.colon)) return name;
        var node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
    }, {
      key: 'jsxParseElementName',
      value: function jsxParseElementName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.jsxParseNamespacedName();

        if (node.type === "JSXNamespacedName") {
          return node;
        }

        while (this.eat(types.dot)) {
          var newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }

        return node;
      }
    }, {
      key: 'jsxParseAttributeValue',
      value: function jsxParseAttributeValue() {
        var node = void 0;

        switch (this.state.type) {
          case types.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);

            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
            }

            return node;

          case types.jsxTagStart:
          case types.string:
            return this.parseExprAtom();

          default:
            throw this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
    }, {
      key: 'jsxParseEmptyExpression',
      value: function jsxParseEmptyExpression() {
        var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      }
    }, {
      key: 'jsxParseSpreadChild',
      value: function jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types.braceR);
        return this.finishNode(node, "JSXSpreadChild");
      }
    }, {
      key: 'jsxParseExpressionContainer',
      value: function jsxParseExpressionContainer(node) {
        if (this.match(types.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          node.expression = this.parseExpression();
        }

        this.expect(types.braceR);
        return this.finishNode(node, "JSXExpressionContainer");
      }
    }, {
      key: 'jsxParseAttribute',
      value: function jsxParseAttribute() {
        var node = this.startNode();

        if (this.eat(types.braceL)) {
          this.expect(types.ellipsis);
          node.argument = this.parseMaybeAssign();
          this.expect(types.braceR);
          return this.finishNode(node, "JSXSpreadAttribute");
        }

        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
    }, {
      key: 'jsxParseOpeningElementAt',
      value: function jsxParseOpeningElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningFragment");
        }

        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
    }, {
      key: 'jsxParseOpeningElementAfterName',
      value: function jsxParseOpeningElementAfterName(node) {
        var attributes = [];

        while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }

        node.attributes = attributes;
        node.selfClosing = this.eat(types.slash);
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningElement");
      }
    }, {
      key: 'jsxParseClosingElementAt',
      value: function jsxParseClosingElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXClosingFragment");
        }

        node.name = this.jsxParseElementName();
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXClosingElement");
      }
    }, {
      key: 'jsxParseElementAt',
      value: function jsxParseElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        var children = [];
        var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        var closingElement = null;

        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case types.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();

                if (this.eat(types.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }

                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

              case types.jsxText:
                children.push(this.parseExprAtom());
                break;

              case types.braceL:
                {
                  var _node5 = this.startNode();
                  this.next();

                  if (this.match(types.ellipsis)) {
                    children.push(this.jsxParseSpreadChild(_node5));
                  } else {
                    children.push(this.jsxParseExpressionContainer(_node5));
                  }

                  break;
                }

              default:
                throw this.unexpected();
            }
          }

          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(closingElement.start, "Expected corresponding JSX closing tag for <>");
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
            }
          }
        }

        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }

        node.children = children;

        if (this.isRelational("<")) {
          throw this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag. " + "Did you want a JSX fragment <>...</>?");
        }

        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
    }, {
      key: 'jsxParseElement',
      value: function jsxParseElement() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      }
    }, {
      key: 'parseExprAtom',
      value: function parseExprAtom(refShortHandDefaultPos) {
        if (this.match(types.jsxText)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(types.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
          this.finishToken(types.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'parseExprAtom', this).call(this, refShortHandDefaultPos);
        }
      }
    }, {
      key: 'getTokenFromCode',
      value: function getTokenFromCode(code) {
        if (this.state.inPropertyName) return _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'getTokenFromCode', this).call(this, code);
        var context = this.curContext();

        if (context === types$1.j_expr) {
          return this.jsxReadToken();
        }

        if (context === types$1.j_oTag || context === types$1.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }

          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context === types$1.j_oTag) {
            return this.jsxReadString(code);
          }
        }

        if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagStart);
        }

        return _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'getTokenFromCode', this).call(this, code);
      }
    }, {
      key: 'updateContext',
      value: function updateContext(prevType) {
        if (this.match(types.braceL)) {
          var curContext = this.curContext();

          if (curContext === types$1.j_oTag) {
            this.state.context.push(types$1.braceExpression);
          } else if (curContext === types$1.j_expr) {
            this.state.context.push(types$1.templateQuasi);
          } else {
            _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'updateContext', this).call(this, prevType);
          }

          this.state.exprAllowed = true;
        } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
          this.state.context.length -= 2;
          this.state.context.push(types$1.j_cTag);
          this.state.exprAllowed = false;
        } else {
          return _get(_class3.prototype.__proto__ || Object.getPrototypeOf(_class3.prototype), 'updateContext', this).call(this, prevType);
        }
      }
    }]);

    return _class3;
  }(superClass);
};

var Scope = function Scope(flags) {
  _classCallCheck(this, Scope);

  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.flags = flags;
};

var ScopeHandler = function () {
  function ScopeHandler(raise, inModule) {
    _classCallCheck(this, ScopeHandler);

    this.scopeStack = [];
    this.undefinedExports = new Map();
    this.raise = raise;
    this.inModule = inModule;
  }

  _createClass(ScopeHandler, [{
    key: 'createScope',
    value: function createScope(flags) {
      return new Scope(flags);
    }
  }, {
    key: 'enter',
    value: function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
  }, {
    key: 'exit',
    value: function exit() {
      this.scopeStack.pop();
    }
  }, {
    key: 'treatFunctionsAsVarInScope',
    value: function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }
  }, {
    key: 'declareName',
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
  }, {
    key: 'maybeExportDefined',
    value: function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
  }, {
    key: 'checkRedeclarationInScope',
    value: function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, 'Identifier \'' + name + '\' has already been declared');
      }
    }
  }, {
    key: 'isRedeclaredInScope',
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;
      }

      return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
    }
  }, {
    key: 'checkLocalExport',
    value: function checkLocalExport(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
        this.undefinedExports.set(id.name, id.start);
      }
    }
  }, {
    key: 'currentScope',
    value: function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
  }, {
    key: 'currentVarScope',
    value: function currentVarScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    }
  }, {
    key: 'currentThisScope',
    value: function currentThisScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    }
  }, {
    key: 'inFunction',
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: 'inGenerator',
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    }
  }, {
    key: 'inAsync',
    get: function get() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    }
  }, {
    key: 'allowSuper',
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    }
  }, {
    key: 'allowDirectSuper',
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    }
  }, {
    key: 'inNonArrowFunction',
    get: function get() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    }
  }, {
    key: 'treatFunctionsAsVar',
    get: function get() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
  }]);

  return ScopeHandler;
}();

var TypeScriptScope = function (_Scope) {
  _inherits(TypeScriptScope, _Scope);

  function TypeScriptScope() {
    var _ref15;

    _classCallCheck(this, TypeScriptScope);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this18 = _possibleConstructorReturn(this, (_ref15 = TypeScriptScope.__proto__ || Object.getPrototypeOf(TypeScriptScope)).call.apply(_ref15, [this].concat(args)));

    _this18.types = [];
    _this18.enums = [];
    _this18.constEnums = [];
    _this18.classes = [];
    _this18.exportOnlyBindings = [];
    return _this18;
  }

  return TypeScriptScope;
}(Scope);

var TypeScriptScopeHandler = function (_ScopeHandler) {
  _inherits(TypeScriptScopeHandler, _ScopeHandler);

  function TypeScriptScopeHandler() {
    _classCallCheck(this, TypeScriptScopeHandler);

    return _possibleConstructorReturn(this, (TypeScriptScopeHandler.__proto__ || Object.getPrototypeOf(TypeScriptScopeHandler)).apply(this, arguments));
  }

  _createClass(TypeScriptScopeHandler, [{
    key: 'createScope',
    value: function createScope(flags) {
      return new TypeScriptScope(flags);
    }
  }, {
    key: 'declareName',
    value: function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      _get(TypeScriptScopeHandler.prototype.__proto__ || Object.getPrototypeOf(TypeScriptScopeHandler.prototype), 'declareName', this).apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    }
  }, {
    key: 'isRedeclaredInScope',
    value: function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return _get(TypeScriptScopeHandler.prototype.__proto__ || Object.getPrototypeOf(TypeScriptScopeHandler.prototype), 'isRedeclaredInScope', this).apply(this, arguments);
    }
  }, {
    key: 'checkLocalExport',
    value: function checkLocalExport(id) {
      if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
        _get(TypeScriptScopeHandler.prototype.__proto__ || Object.getPrototypeOf(TypeScriptScopeHandler.prototype), 'checkLocalExport', this).call(this, id);
      }
    }
  }]);

  return TypeScriptScopeHandler;
}(ScopeHandler);

function nonNull(x) {
  if (x == null) {
    throw new Error('Unexpected ' + x + ' value.');
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

var typescript = function typescript(superClass) {
  return function (_superClass4) {
    _inherits(_class4, _superClass4);

    function _class4() {
      _classCallCheck(this, _class4);

      return _possibleConstructorReturn(this, (_class4.__proto__ || Object.getPrototypeOf(_class4)).apply(this, arguments));
    }

    _createClass(_class4, [{
      key: 'getScopeHandler',
      value: function getScopeHandler() {
        return TypeScriptScopeHandler;
      }
    }, {
      key: 'tsIsIdentifier',
      value: function tsIsIdentifier() {
        return this.match(types.name);
      }
    }, {
      key: 'tsNextTokenCanFollowModifier',
      value: function tsNextTokenCanFollowModifier() {
        this.next();
        return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
      }
    }, {
      key: 'tsParseModifier',
      value: function tsParseModifier(allowedModifiers) {
        if (!this.match(types.name)) {
          return undefined;
        }

        var modifier = this.state.value;

        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }

        return undefined;
      }
    }, {
      key: 'tsParseModifiers',
      value: function tsParseModifiers(allowedModifiers) {
        var modifiers = Object.create(null);

        while (true) {
          var startPos = this.state.start;
          var modifier = this.tsParseModifier(allowedModifiers);
          if (!modifier) break;

          if (Object.hasOwnProperty.call(modifiers, modifier)) {
            this.raise(startPos, 'Duplicate modifier: \'' + modifier + '\'');
          }

          modifiers[modifier] = true;
        }

        return modifiers;
      }
    }, {
      key: 'tsIsListTerminator',
      value: function tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(types.braceR);

          case "HeritageClauseElement":
            return this.match(types.braceL);

          case "TupleElementTypes":
            return this.match(types.bracketR);

          case "TypeParametersOrArguments":
            return this.isRelational(">");
        }

        throw new Error("Unreachable");
      }
    }, {
      key: 'tsParseList',
      value: function tsParseList(kind, parseElement) {
        var result = [];

        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }

        return result;
      }
    }, {
      key: 'tsParseDelimitedList',
      value: function tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
      }
    }, {
      key: 'tsParseDelimitedListWorker',
      value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        var result = [];

        while (true) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }

          var element = parseElement();

          if (element == null) {
            return undefined;
          }

          result.push(element);

          if (this.eat(types.comma)) {
            continue;
          }

          if (this.tsIsListTerminator(kind)) {
            break;
          }

          if (expectSuccess) {
            this.expect(types.comma);
          }

          return undefined;
        }

        return result;
      }
    }, {
      key: 'tsParseBracketedList',
      value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types.bracketL);
          } else {
            this.expectRelational("<");
          }
        }

        var result = this.tsParseDelimitedList(kind, parseElement);

        if (bracket) {
          this.expect(types.bracketR);
        } else {
          this.expectRelational(">");
        }

        return result;
      }
    }, {
      key: 'tsParseImportType',
      value: function tsParseImportType() {
        var node = this.startNode();
        this.expect(types._import);
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          this.raise(this.state.start, "Argument in a type import must be a string literal");
        }

        node.argument = this.parseExprAtom();
        this.expect(types.parenR);

        if (this.eat(types.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSImportType");
      }
    }, {
      key: 'tsParseEntityName',
      value: function tsParseEntityName(allowReservedWords) {
        var entity = this.parseIdentifier();

        while (this.eat(types.dot)) {
          var node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }

        return entity;
      }
    }, {
      key: 'tsParseTypeReference',
      value: function tsParseTypeReference() {
        var node = this.startNode();
        node.typeName = this.tsParseEntityName(false);

        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSTypeReference");
      }
    }, {
      key: 'tsParseThisTypePredicate',
      value: function tsParseThisTypePredicate(lhs) {
        this.next();
        var node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        return this.finishNode(node, "TSTypePredicate");
      }
    }, {
      key: 'tsParseThisTypeNode',
      value: function tsParseThisTypeNode() {
        var node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
    }, {
      key: 'tsParseTypeQuery',
      value: function tsParseTypeQuery() {
        var node = this.startNode();
        this.expect(types._typeof);

        if (this.match(types._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }

        return this.finishNode(node, "TSTypeQuery");
      }
    }, {
      key: 'tsParseTypeParameter',
      value: function tsParseTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsEatThenParseType(types._extends);
        node.default = this.tsEatThenParseType(types.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
    }, {
      key: 'tsTryParseTypeParameters',
      value: function tsTryParseTypeParameters() {
        if (this.isRelational("<")) {
          return this.tsParseTypeParameters();
        }
      }
    }, {
      key: 'tsParseTypeParameters',
      value: function tsParseTypeParameters() {
        var node = this.startNode();

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
    }, {
      key: 'tsTryNextParseConstantContext',
      value: function tsTryNextParseConstantContext() {
        if (this.lookahead().type === types._const) {
          this.next();
          return this.tsParseTypeReference();
        }

        return null;
      }
    }, {
      key: 'tsFillSignature',
      value: function tsFillSignature(returnToken, signature) {
        var returnTokenRequired = returnToken === types.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types.parenL);
        signature.parameters = this.tsParseBindingListForSignature();

        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
    }, {
      key: 'tsParseBindingListForSignature',
      value: function tsParseBindingListForSignature() {
        var _this21 = this;

        return this.parseBindingList(types.parenR, 41).map(function (pattern) {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            _this21.raise(pattern.start, "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern," + ('instead got ' + pattern.type));
          }

          return pattern;
        });
      }
    }, {
      key: 'tsParseTypeMemberSemicolon',
      value: function tsParseTypeMemberSemicolon() {
        if (!this.eat(types.comma)) {
          this.semicolon();
        }
      }
    }, {
      key: 'tsParseSignatureMember',
      value: function tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
    }, {
      key: 'tsIsUnambiguouslyIndexSignature',
      value: function tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types.name) && this.match(types.colon);
      }
    }, {
      key: 'tsTryParseIndexSignature',
      value: function tsTryParseIndexSignature(node) {
        if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return undefined;
        }

        this.expect(types.bracketL);
        var id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types.bracketR);
        node.parameters = [id];
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
    }, {
      key: 'tsParsePropertyOrMethodSignature',
      value: function tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types.question)) node.optional = true;
        var nodeAny = node;

        if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
          var method = nodeAny;
          this.tsFillSignature(types.colon, method);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(method, "TSMethodSignature");
        } else {
          var property = nodeAny;
          if (readonly) property.readonly = true;
          var type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
    }, {
      key: 'tsParseTypeMember',
      value: function tsParseTypeMember() {
        var node = this.startNode();

        if (this.match(types.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }

        if (this.match(types._new)) {
          var id = this.startNode();
          this.next();

          if (this.match(types.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }

        var readonly = !!this.tsParseModifier(["readonly"]);
        var idx = this.tsTryParseIndexSignature(node);

        if (idx) {
          if (readonly) node.readonly = true;
          return idx;
        }

        this.parsePropertyName(node);
        return this.tsParsePropertyOrMethodSignature(node, readonly);
      }
    }, {
      key: 'tsParseTypeLiteral',
      value: function tsParseTypeLiteral() {
        var node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
    }, {
      key: 'tsParseObjectTypeMembers',
      value: function tsParseObjectTypeMembers() {
        this.expect(types.braceL);
        var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(types.braceR);
        return members;
      }
    }, {
      key: 'tsIsStartOfMappedType',
      value: function tsIsStartOfMappedType() {
        this.next();

        if (this.eat(types.plusMin)) {
          return this.isContextual("readonly");
        }

        if (this.isContextual("readonly")) {
          this.next();
        }

        if (!this.match(types.bracketL)) {
          return false;
        }

        this.next();

        if (!this.tsIsIdentifier()) {
          return false;
        }

        this.next();
        return this.match(types._in);
      }
    }, {
      key: 'tsParseMappedTypeParameter',
      value: function tsParseMappedTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsExpectThenParseType(types._in);
        return this.finishNode(node, "TSTypeParameter");
      }
    }, {
      key: 'tsParseMappedType',
      value: function tsParseMappedType() {
        var node = this.startNode();
        this.expect(types.braceL);

        if (this.match(types.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }

        this.expect(types.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        this.expect(types.bracketR);

        if (this.match(types.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types.question);
        } else if (this.eat(types.question)) {
          node.optional = true;
        }

        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types.braceR);
        return this.finishNode(node, "TSMappedType");
      }
    }, {
      key: 'tsParseTupleType',
      value: function tsParseTupleType() {
        var _this22 = this;

        var node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var seenOptionalElement = false;
        node.elementTypes.forEach(function (elementNode) {
          if (elementNode.type === "TSOptionalType") {
            seenOptionalElement = true;
          } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
            _this22.raise(elementNode.start, "A required element cannot follow an optional element.");
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
    }, {
      key: 'tsParseTupleElementType',
      value: function tsParseTupleElementType() {
        if (this.match(types.ellipsis)) {
          var restNode = this.startNode();
          this.next();
          restNode.typeAnnotation = this.tsParseType();
          this.checkCommaAfterRest(93);
          return this.finishNode(restNode, "TSRestType");
        }

        var type = this.tsParseType();

        if (this.eat(types.question)) {
          var optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          return this.finishNode(optionalTypeNode, "TSOptionalType");
        }

        return type;
      }
    }, {
      key: 'tsParseParenthesizedType',
      value: function tsParseParenthesizedType() {
        var node = this.startNode();
        this.expect(types.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
    }, {
      key: 'tsParseFunctionOrConstructorType',
      value: function tsParseFunctionOrConstructorType(type) {
        var node = this.startNode();

        if (type === "TSConstructorType") {
          this.expect(types._new);
        }

        this.tsFillSignature(types.arrow, node);
        return this.finishNode(node, type);
      }
    }, {
      key: 'tsParseLiteralTypeNode',
      value: function tsParseLiteralTypeNode() {
        var _this23 = this;

        var node = this.startNode();

        node.literal = function () {
          switch (_this23.state.type) {
            case types.num:
            case types.string:
            case types._true:
            case types._false:
              return _this23.parseExprAtom();

            default:
              throw _this23.unexpected();
          }
        }();

        return this.finishNode(node, "TSLiteralType");
      }
    }, {
      key: 'tsParseTemplateLiteralType',
      value: function tsParseTemplateLiteralType() {
        var node = this.startNode();
        var templateNode = this.parseTemplate(false);

        if (templateNode.expressions.length > 0) {
          this.raise(templateNode.expressions[0].start, "Template literal types cannot have any substitution");
        }

        node.literal = templateNode;
        return this.finishNode(node, "TSLiteralType");
      }
    }, {
      key: 'tsParseThisTypeOrThisTypePredicate',
      value: function tsParseThisTypeOrThisTypePredicate() {
        var thisKeyword = this.tsParseThisTypeNode();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
    }, {
      key: 'tsParseNonArrayType',
      value: function tsParseNonArrayType() {
        switch (this.state.type) {
          case types.name:
          case types._void:
          case types._null:
            {
              var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

              if (type !== undefined && this.lookaheadCharCode() !== 46) {
                var node = this.startNode();
                this.next();
                return this.finishNode(node, type);
              }

              return this.tsParseTypeReference();
            }

          case types.string:
          case types.num:
          case types._true:
          case types._false:
            return this.tsParseLiteralTypeNode();

          case types.plusMin:
            if (this.state.value === "-") {
              var _node6 = this.startNode();

              if (this.lookahead().type !== types.num) {
                throw this.unexpected();
              }

              _node6.literal = this.parseMaybeUnary();
              return this.finishNode(_node6, "TSLiteralType");
            }

            break;

          case types._this:
            return this.tsParseThisTypeOrThisTypePredicate();

          case types._typeof:
            return this.tsParseTypeQuery();

          case types._import:
            return this.tsParseImportType();

          case types.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

          case types.bracketL:
            return this.tsParseTupleType();

          case types.parenL:
            return this.tsParseParenthesizedType();

          case types.backQuote:
            return this.tsParseTemplateLiteralType();
        }

        throw this.unexpected();
      }
    }, {
      key: 'tsParseArrayTypeOrHigher',
      value: function tsParseArrayTypeOrHigher() {
        var type = this.tsParseNonArrayType();

        while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
          if (this.match(types.bracketR)) {
            var node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            var _node7 = this.startNodeAtNode(type);
            _node7.objectType = type;
            _node7.indexType = this.tsParseType();
            this.expect(types.bracketR);
            type = this.finishNode(_node7, "TSIndexedAccessType");
          }
        }

        return type;
      }
    }, {
      key: 'tsParseTypeOperator',
      value: function tsParseTypeOperator(operator) {
        var node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }

        return this.finishNode(node, "TSTypeOperator");
      }
    }, {
      key: 'tsCheckTypeAnnotationForReadOnly',
      value: function tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;

          default:
            this.raise(node.start, "'readonly' type modifier is only permitted on array and tuple literal types.");
        }
      }
    }, {
      key: 'tsParseInferType',
      value: function tsParseInferType() {
        var node = this.startNode();
        this.expectContextual("infer");
        var typeParameter = this.startNode();
        typeParameter.name = this.parseIdentifierName(typeParameter.start);
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
    }, {
      key: 'tsParseTypeOperatorOrHigher',
      value: function tsParseTypeOperatorOrHigher() {
        var _this24 = this;

        var operator = ["keyof", "unique", "readonly"].find(function (kw) {
          return _this24.isContextual(kw);
        });
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      }
    }, {
      key: 'tsParseUnionOrIntersectionType',
      value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        this.eat(operator);
        var type = parseConstituentType();

        if (this.match(operator)) {
          var _types = [type];

          while (this.eat(operator)) {
            _types.push(parseConstituentType());
          }

          var node = this.startNodeAtNode(type);
          node.types = _types;
          type = this.finishNode(node, kind);
        }

        return type;
      }
    }, {
      key: 'tsParseIntersectionTypeOrHigher',
      value: function tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
      }
    }, {
      key: 'tsParseUnionTypeOrHigher',
      value: function tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
      }
    }, {
      key: 'tsIsStartOfFunctionType',
      value: function tsIsStartOfFunctionType() {
        if (this.isRelational("<")) {
          return true;
        }

        return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
    }, {
      key: 'tsSkipParameterStart',
      value: function tsSkipParameterStart() {
        if (this.match(types.name) || this.match(types._this)) {
          this.next();
          return true;
        }

        if (this.match(types.braceL)) {
          var braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types.braceR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        if (this.match(types.bracketL)) {
          var _braceStackCounter = 1;
          this.next();

          while (_braceStackCounter > 0) {
            if (this.match(types.bracketL)) {
              ++_braceStackCounter;
            } else if (this.match(types.bracketR)) {
              --_braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        return false;
      }
    }, {
      key: 'tsIsUnambiguouslyStartOfFunctionType',
      value: function tsIsUnambiguouslyStartOfFunctionType() {
        this.next();

        if (this.match(types.parenR) || this.match(types.ellipsis)) {
          return true;
        }

        if (this.tsSkipParameterStart()) {
          if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
            return true;
          }

          if (this.match(types.parenR)) {
            this.next();

            if (this.match(types.arrow)) {
              return true;
            }
          }
        }

        return false;
      }
    }, {
      key: 'tsParseTypeOrTypePredicateAnnotation',
      value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
        var _this25 = this;

        return this.tsInType(function () {
          var t = _this25.startNode();
          _this25.expect(returnToken);
          var asserts = _this25.tsTryParse(_this25.tsParseTypePredicateAsserts.bind(_this25));

          if (asserts && _this25.match(types._this)) {
            var thisTypePredicate = _this25.tsParseThisTypeOrThisTypePredicate();

            if (thisTypePredicate.type === "TSThisType") {
              var _node8 = _this25.startNodeAtNode(t);
              _node8.parameterName = thisTypePredicate;
              _node8.asserts = true;
              thisTypePredicate = _this25.finishNode(_node8, "TSTypePredicate");
            } else {
              thisTypePredicate.asserts = true;
            }

            t.typeAnnotation = thisTypePredicate;
            return _this25.finishNode(t, "TSTypeAnnotation");
          }

          var typePredicateVariable = _this25.tsIsIdentifier() && _this25.tsTryParse(_this25.tsParseTypePredicatePrefix.bind(_this25));

          if (!typePredicateVariable) {
            if (!asserts) {
              return _this25.tsParseTypeAnnotation(false, t);
            }

            var _node9 = _this25.startNodeAtNode(t);
            _node9.parameterName = _this25.parseIdentifier();
            _node9.asserts = asserts;
            t.typeAnnotation = _this25.finishNode(_node9, "TSTypePredicate");
            return _this25.finishNode(t, "TSTypeAnnotation");
          }

          var type = _this25.tsParseTypeAnnotation(false);
          var node = _this25.startNodeAtNode(t);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = _this25.finishNode(node, "TSTypePredicate");
          return _this25.finishNode(t, "TSTypeAnnotation");
        });
      }
    }, {
      key: 'tsTryParseTypeOrTypePredicateAnnotation',
      value: function tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
      }
    }, {
      key: 'tsTryParseTypeAnnotation',
      value: function tsTryParseTypeAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
      }
    }, {
      key: 'tsTryParseType',
      value: function tsTryParseType() {
        return this.tsEatThenParseType(types.colon);
      }
    }, {
      key: 'tsParseTypePredicatePrefix',
      value: function tsParseTypePredicatePrefix() {
        var id = this.parseIdentifier();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
    }, {
      key: 'tsParseTypePredicateAsserts',
      value: function tsParseTypePredicateAsserts() {
        if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
          return false;
        }

        var containsEsc = this.state.containsEsc;
        this.next();

        if (!this.match(types.name) && !this.match(types._this)) {
          return false;
        }

        if (containsEsc) {
          this.raise(this.state.lastTokStart, "Escape sequence in keyword asserts");
        }

        return true;
      }
    }, {
      key: 'tsParseTypeAnnotation',
      value: function tsParseTypeAnnotation() {
        var _this26 = this;

        var eatColon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();

        this.tsInType(function () {
          if (eatColon) _this26.expect(types.colon);
          t.typeAnnotation = _this26.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
    }, {
      key: 'tsParseType',
      value: function tsParseType() {
        assert(this.state.inType);
        var type = this.tsParseNonConditionalType();

        if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
          return type;
        }

        var node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types.question);
        node.trueType = this.tsParseType();
        this.expect(types.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      }
    }, {
      key: 'tsParseNonConditionalType',
      value: function tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }

        if (this.match(types._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        }

        return this.tsParseUnionTypeOrHigher();
      }
    }, {
      key: 'tsParseTypeAssertion',
      value: function tsParseTypeAssertion() {
        var node = this.startNode();

        var _const = this.tsTryNextParseConstantContext();

        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational(">");
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
    }, {
      key: 'tsParseHeritageClause',
      value: function tsParseHeritageClause(descriptor) {
        var originalStart = this.state.start;
        var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

        if (!delimitedList.length) {
          this.raise(originalStart, '\'' + descriptor + '\' list cannot be empty.');
        }

        return delimitedList;
      }
    }, {
      key: 'tsParseExpressionWithTypeArguments',
      value: function tsParseExpressionWithTypeArguments() {
        var node = this.startNode();
        node.expression = this.tsParseEntityName(false);

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSExpressionWithTypeArguments");
      }
    }, {
      key: 'tsParseInterfaceDeclaration',
      value: function tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
        node.typeParameters = this.tsTryParseTypeParameters();

        if (this.eat(types._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }

        var body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
    }, {
      key: 'tsParseTypeAliasDeclaration',
      value: function tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsExpectThenParseType(types.eq);
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
    }, {
      key: 'tsInNoContext',
      value: function tsInNoContext(cb) {
        var oldContext = this.state.context;
        this.state.context = [oldContext[0]];

        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
    }, {
      key: 'tsInType',
      value: function tsInType(cb) {
        var oldInType = this.state.inType;
        this.state.inType = true;

        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
    }, {
      key: 'tsEatThenParseType',
      value: function tsEatThenParseType(token) {
        return !this.match(token) ? undefined : this.tsNextThenParseType();
      }
    }, {
      key: 'tsExpectThenParseType',
      value: function tsExpectThenParseType(token) {
        var _this27 = this;

        return this.tsDoThenParseType(function () {
          return _this27.expect(token);
        });
      }
    }, {
      key: 'tsNextThenParseType',
      value: function tsNextThenParseType() {
        var _this28 = this;

        return this.tsDoThenParseType(function () {
          return _this28.next();
        });
      }
    }, {
      key: 'tsDoThenParseType',
      value: function tsDoThenParseType(cb) {
        var _this29 = this;

        return this.tsInType(function () {
          cb();
          return _this29.tsParseType();
        });
      }
    }, {
      key: 'tsParseEnumMember',
      value: function tsParseEnumMember() {
        var node = this.startNode();
        node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

        if (this.eat(types.eq)) {
          node.initializer = this.parseMaybeAssign();
        }

        return this.finishNode(node, "TSEnumMember");
      }
    }, {
      key: 'tsParseEnumDeclaration',
      value: function tsParseEnumDeclaration(node, isConst) {
        if (isConst) node.const = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
        this.expect(types.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(types.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
    }, {
      key: 'tsParseModuleBlock',
      value: function tsParseModuleBlock() {
        var node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types.braceL);
        this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
    }, {
      key: 'tsParseModuleOrNamespaceDeclaration',
      value: function tsParseModuleOrNamespaceDeclaration(node) {
        var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        node.id = this.parseIdentifier();

        if (!nested) {
          this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
        }

        if (this.eat(types.dot)) {
          var inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          this.scope.exit();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      }
    }, {
      key: 'tsParseAmbientExternalModuleDeclaration',
      value: function tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual("global")) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }

        if (this.match(types.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          this.scope.exit();
        } else {
          this.semicolon();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      }
    }, {
      key: 'tsParseImportEqualsDeclaration',
      value: function tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_LEXICAL, undefined, "import equals declaration");
        this.expect(types.eq);
        node.moduleReference = this.tsParseModuleReference();
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
    }, {
      key: 'tsIsExternalModuleReference',
      value: function tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
    }, {
      key: 'tsParseModuleReference',
      value: function tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
    }, {
      key: 'tsParseExternalModuleReference',
      value: function tsParseExternalModuleReference() {
        var node = this.startNode();
        this.expectContextual("require");
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          throw this.unexpected();
        }

        node.expression = this.parseExprAtom();
        this.expect(types.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
    }, {
      key: 'tsLookAhead',
      value: function tsLookAhead(f) {
        var state = this.state.clone();
        var res = f();
        this.state = state;
        return res;
      }
    }, {
      key: 'tsTryParseAndCatch',
      value: function tsTryParseAndCatch(f) {
        var result = this.tryParse(function (abort) {
          return f() || abort();
        });
        if (result.aborted || !result.node) return undefined;
        if (result.error) this.state = result.failState;
        return result.node;
      }
    }, {
      key: 'tsTryParse',
      value: function tsTryParse(f) {
        var state = this.state.clone();
        var result = f();

        if (result !== undefined && result !== false) {
          return result;
        } else {
          this.state = state;
          return undefined;
        }
      }
    }, {
      key: 'tsTryParseDeclare',
      value: function tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }

        var starttype = this.state.type;
        var kind = void 0;

        if (this.isContextual("let")) {
          starttype = types._var;
          kind = "let";
        }

        switch (starttype) {
          case types._function:
            return this.parseFunctionStatement(nany, false, true);

          case types._class:
            nany.declare = true;
            return this.parseClass(nany, true, false);

          case types._const:
            if (this.match(types._const) && this.isLookaheadContextual("enum")) {
              this.expect(types._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(nany, true);
            }

          case types._var:
            kind = kind || this.state.value;
            return this.parseVarStatement(nany, kind);

          case types.name:
            {
              var value = this.state.value;

              if (value === "global") {
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              } else {
                return this.tsParseDeclaration(nany, value, true);
              }
            }
        }
      }
    }, {
      key: 'tsTryParseExportDeclaration',
      value: function tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      }
    }, {
      key: 'tsParseExpressionStatement',
      value: function tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare":
            {
              var declaration = this.tsTryParseDeclare(node);

              if (declaration) {
                declaration.declare = true;
                return declaration;
              }

              break;
            }

          case "global":
            if (this.match(types.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              var mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }

            break;

          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      }
    }, {
      key: 'tsParseDeclaration',
      value: function tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
              var cls = node;
              cls.abstract = true;

              if (next) {
                this.next();

                if (!this.match(types._class)) {
                  this.unexpected(null, types._class);
                }
              }

              return this.parseClass(cls, true, false);
            }

            break;

          case "enum":
            if (next || this.match(types.name)) {
              if (next) this.next();
              return this.tsParseEnumDeclaration(node, false);
            }

            break;

          case "interface":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseInterfaceDeclaration(node);
            }

            break;

          case "module":
            if (next) this.next();

            if (this.match(types.string)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "namespace":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "type":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseTypeAliasDeclaration(node);
            }

            break;
        }
      }
    }, {
      key: 'tsCheckLineTerminatorAndMatch',
      value: function tsCheckLineTerminatorAndMatch(tokenType, next) {
        return (next || this.match(tokenType)) && !this.isLineTerminator();
      }
    }, {
      key: 'tsTryParseGenericAsyncArrowFunction',
      value: function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        var _this30 = this;

        if (!this.isRelational("<")) {
          return undefined;
        }

        var res = this.tsTryParseAndCatch(function () {
          var node = _this30.startNodeAt(startPos, startLoc);
          node.typeParameters = _this30.tsParseTypeParameters();
          _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseFunctionParams', _this30).call(_this30, node);
          node.returnType = _this30.tsTryParseTypeOrTypePredicateAnnotation();
          _this30.expect(types.arrow);
          return node;
        });

        if (!res) {
          return undefined;
        }

        return this.parseArrowExpression(res, null, true);
      }
    }, {
      key: 'tsParseTypeArguments',
      value: function tsParseTypeArguments() {
        var _this31 = this;

        var node = this.startNode();
        node.params = this.tsInType(function () {
          return _this31.tsInNoContext(function () {
            _this31.expectRelational("<");
            return _this31.tsParseDelimitedList("TypeParametersOrArguments", _this31.tsParseType.bind(_this31));
          });
        });
        this.state.exprAllowed = false;
        this.expectRelational(">");
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
    }, {
      key: 'tsIsDeclarationStart',
      value: function tsIsDeclarationStart() {
        if (this.match(types.name)) {
          switch (this.state.value) {
            case "abstract":
            case "declare":
            case "enum":
            case "interface":
            case "module":
            case "namespace":
            case "type":
              return true;
          }
        }

        return false;
      }
    }, {
      key: 'isExportDefaultSpecifier',
      value: function isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'isExportDefaultSpecifier', this).call(this);
      }
    }, {
      key: 'parseAssignableListItem',
      value: function parseAssignableListItem(allowModifiers, decorators) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var accessibility = void 0;
        var readonly = false;

        if (allowModifiers) {
          accessibility = this.parseAccessModifier();
          readonly = !!this.tsParseModifier(["readonly"]);
        }

        var left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (accessibility || readonly) {
          var pp = this.startNodeAt(startPos, startLoc);

          if (decorators.length) {
            pp.decorators = decorators;
          }

          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;

          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, "A parameter property may not be declared using a binding pattern.");
          }

          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      }
    }, {
      key: 'parseFunctionBodyAndFinish',
      value: function parseFunctionBodyAndFinish(node, type) {
        var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
        }

        var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

        if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }

        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseFunctionBodyAndFinish', this).call(this, node, type, isMethod);
      }
    }, {
      key: 'registerFunctionStatementId',
      value: function registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
        } else {
          _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'registerFunctionStatementId', this).apply(this, arguments);
        }
      }
    }, {
      key: 'parseSubscript',
      value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var _this32 = this;

        if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
          this.state.exprAllowed = false;
          this.next();
          var nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }

        if (this.isRelational("<")) {
          var result = this.tsTryParseAndCatch(function () {
            if (!noCalls && _this32.atPossibleAsync(base)) {
              var asyncArrowFn = _this32.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }

            var node = _this32.startNodeAt(startPos, startLoc);
            node.callee = base;
            var typeArguments = _this32.tsParseTypeArguments();

            if (typeArguments) {
              if (!noCalls && _this32.eat(types.parenL)) {
                node.arguments = _this32.parseCallExpressionArguments(types.parenR, false);
                node.typeParameters = typeArguments;
                return _this32.finishCallExpression(node, state.optionalChainMember);
              } else if (_this32.match(types.backQuote)) {
                return _this32.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
              }
            }

            _this32.unexpected();
          });
          if (result) return result;
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseSubscript', this).call(this, base, startPos, startLoc, noCalls, state);
      }
    }, {
      key: 'parseNewArguments',
      value: function parseNewArguments(node) {
        var _this33 = this;

        if (this.isRelational("<")) {
          var typeParameters = this.tsTryParseAndCatch(function () {
            var args = _this33.tsParseTypeArguments();
            if (!_this33.match(types.parenL)) _this33.unexpected();
            return args;
          });

          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }

        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseNewArguments', this).call(this, node);
      }
    }, {
      key: 'parseExprOp',
      value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;

          var _const = this.tsTryNextParseConstantContext();

          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }

          this.finishNode(node, "TSAsExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseExprOp', this).call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);
      }
    }, {
      key: 'checkReservedWord',
      value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {}
    }, {
      key: 'checkDuplicateExports',
      value: function checkDuplicateExports() {}
    }, {
      key: 'parseImport',
      value: function parseImport(node) {
        if (this.match(types.name) && this.lookahead().type === types.eq) {
          return this.tsParseImportEqualsDeclaration(node);
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseImport', this).call(this, node);
      }
    }, {
      key: 'parseExport',
      value: function parseExport(node) {
        if (this.match(types._import)) {
          this.expect(types._import);
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types.eq)) {
          var assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual("as")) {
          var decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseExport', this).call(this, node);
        }
      }
    }, {
      key: 'isAbstractClass',
      value: function isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types._class;
      }
    }, {
      key: 'parseExportDefaultExpression',
      value: function parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          var cls = this.startNode();
          this.next();
          this.parseClass(cls, true, true);
          cls.abstract = true;
          return cls;
        }

        if (this.state.value === "interface") {
          var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
          if (result) return result;
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseExportDefaultExpression', this).call(this);
      }
    }, {
      key: 'parseStatementContent',
      value: function parseStatementContent(context, topLevel) {
        if (this.state.type === types._const) {
          var ahead = this.lookahead();

          if (ahead.type === types.name && ahead.value === "enum") {
            var node = this.startNode();
            this.expect(types._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(node, true);
          }
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseStatementContent', this).call(this, context, topLevel);
      }
    }, {
      key: 'parseAccessModifier',
      value: function parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
    }, {
      key: 'parseClassMember',
      value: function parseClassMember(classBody, member, state, constructorAllowsSuper) {
        var accessibility = this.parseAccessModifier();
        if (accessibility) member.accessibility = accessibility;
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassMember', this).call(this, classBody, member, state, constructorAllowsSuper);
      }
    }, {
      key: 'parseClassMemberWithIsStatic',
      value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
        var modifiers = this.tsParseModifiers(["abstract", "readonly", "declare"]);
        Object.assign(member, modifiers);
        var idx = this.tsTryParseIndexSignature(member);

        if (idx) {
          classBody.body.push(idx);

          if (modifiers.abstract) {
            this.raise(member.start, "Index signatures cannot have the 'abstract' modifier");
          }

          if (isStatic) {
            this.raise(member.start, "Index signatures cannot have the 'static' modifier");
          }

          if (member.accessibility) {
            this.raise(member.start, 'Index signatures cannot have an accessibility modifier (\'' + member.accessibility + '\')');
          }

          return;
        }

        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassMemberWithIsStatic', this).call(this, classBody, member, state, isStatic, constructorAllowsSuper);
      }
    }, {
      key: 'parsePostMemberNameModifiers',
      value: function parsePostMemberNameModifiers(methodOrProp) {
        var optional = this.eat(types.question);
        if (optional) methodOrProp.optional = true;

        if (methodOrProp.readonly && this.match(types.parenL)) {
          this.raise(methodOrProp.start, "Class methods cannot have the 'readonly' modifier");
        }

        if (methodOrProp.declare && this.match(types.parenL)) {
          this.raise(methodOrProp.start, "Class methods cannot have the 'declare' modifier");
        }
      }
    }, {
      key: 'parseExpressionStatement',
      value: function parseExpressionStatement(node, expr) {
        var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
        return decl || _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseExpressionStatement', this).call(this, node, expr);
      }
    }, {
      key: 'shouldParseExportDeclaration',
      value: function shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'shouldParseExportDeclaration', this).call(this);
      }
    }, {
      key: 'parseConditional',
      value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        var _this34 = this;

        if (!refNeedsArrowPos || !this.match(types.question)) {
          return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseConditional', this).call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);
        }

        var result = this.tryParse(function () {
          return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseConditional', _this34).call(_this34, expr, noIn, startPos, startLoc);
        });

        if (!result.node) {
          refNeedsArrowPos.start = result.error.pos || this.state.start;
          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      }
    }, {
      key: 'parseParenItem',
      value: function parseParenItem(node, startPos, startLoc) {
        node = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseParenItem', this).call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }

        return node;
      }
    }, {
      key: 'parseExportDeclaration',
      value: function parseExportDeclaration(node) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var isDeclare = this.eatContextual("declare");
        var declaration = void 0;

        if (this.match(types.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }

        if (!declaration) {
          declaration = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseExportDeclaration', this).call(this, node);
        }

        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }

        return declaration;
      }
    }, {
      key: 'parseClassId',
      value: function parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) {
          return;
        }

        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassId', this).call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
      }
    }, {
      key: 'parseClassPropertyAnnotation',
      value: function parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types.bang)) {
          node.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
    }, {
      key: 'parseClassProperty',
      value: function parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);

        if (node.declare && this.match(types.equal)) {
          this.raise(this.state.start, "'declare' class fields cannot have an initializer");
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassProperty', this).call(this, node);
      }
    }, {
      key: 'parseClassPrivateProperty',
      value: function parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(node.start, "Private elements cannot have the 'abstract' modifier.");
        }

        if (node.accessibility) {
          this.raise(node.start, 'Private elements cannot have an accessibility modifier (\'' + node.accessibility + '\')');
        }

        this.parseClassPropertyAnnotation(node);
        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassPrivateProperty', this).call(this, node);
      }
    }, {
      key: 'pushClassMethod',
      value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'pushClassMethod', this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
    }, {
      key: 'pushClassPrivateMethod',
      value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'pushClassPrivateMethod', this).call(this, classBody, method, isGenerator, isAsync);
      }
    }, {
      key: 'parseClassSuper',
      value: function parseClassSuper(node) {
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseClassSuper', this).call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }

        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
    }, {
      key: 'parseObjPropValue',
      value: function parseObjPropValue(prop) {
        var _get2;

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) prop.typeParameters = typeParameters;

        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        (_get2 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseObjPropValue', this)).call.apply(_get2, [this, prop].concat(args));
      }
    }, {
      key: 'parseFunctionParams',
      value: function parseFunctionParams(node, allowModifiers) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseFunctionParams', this).call(this, node, allowModifiers);
      }
    }, {
      key: 'parseVarId',
      value: function parseVarId(decl, kind) {
        _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseVarId', this).call(this, decl, kind);

        if (decl.id.type === "Identifier" && this.eat(types.bang)) {
          decl.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
    }, {
      key: 'parseAsyncArrowFromCallExpression',
      value: function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseAsyncArrowFromCallExpression', this).call(this, node, call);
      }
    }, {
      key: 'parseMaybeAssign',
      value: function parseMaybeAssign() {
        var _this35 = this;

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var state = void 0;
        var jsx = void 0;
        var typeCast = void 0;

        if (this.match(types.jsxTagStart)) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            var _get3;

            return (_get3 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeAssign', _this35)).call.apply(_get3, [_this35].concat(args));
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;


          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (!(jsx && jsx.error) && !this.isRelational("<")) {
          var _get4;

          return (_get4 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeAssign', this)).call.apply(_get4, [this].concat(args));
        }

        var typeParameters = void 0;
        state = state || this.state.clone();
        var arrow = this.tryParse(function (abort) {
          var _get5;

          typeParameters = _this35.tsParseTypeParameters();
          var expr = (_get5 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeAssign', _this35)).call.apply(_get5, [_this35].concat(args));

          if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
            abort();
          }

          if (typeParameters && typeParameters.params.length !== 0) {
            _this35.resetStartLocationFromNode(expr, typeParameters);
          }

          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;

        if (!jsx) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(function () {
            var _get6;

            return (_get6 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeAssign', _this35)).call.apply(_get6, [_this35].concat(args));
          }, state);
          if (!typeCast.error) return typeCast.node;
        }

        if (jsx && jsx.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if (typeCast && typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }

        if (jsx && jsx.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if (typeCast && typeCast.thrown) throw typeCast.error;
        throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;
      }
    }, {
      key: 'parseMaybeUnary',
      value: function parseMaybeUnary(refShorthandDefaultPos) {
        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
          return this.tsParseTypeAssertion();
        } else {
          return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeUnary', this).call(this, refShorthandDefaultPos);
        }
      }
    }, {
      key: 'parseArrow',
      value: function parseArrow(node) {
        var _this36 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function (abort) {
            var returnType = _this36.tsParseTypeOrTypePredicateAnnotation(types.colon);
            if (_this36.canInsertSemicolon() || !_this36.match(types.arrow)) abort();
            return returnType;
          });
          if (result.aborted) return;

          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseArrow', this).call(this, node);
      }
    }, {
      key: 'parseAssignableListItemTypes',
      value: function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
          }

          param.optional = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
    }, {
      key: 'toAssignable',
      value: function toAssignable(node, isBinding, contextDescription) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'toAssignable', this).call(this, this.typeCastToParameter(node), isBinding, contextDescription);

          case "TSParameterProperty":
            return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'toAssignable', this).call(this, node, isBinding, contextDescription);

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
            return node;

          default:
            return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'toAssignable', this).call(this, node, isBinding, contextDescription);
        }
      }
    }, {
      key: 'checkLVal',
      value: function checkLVal(expr) {
        var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
        var checkClashes = arguments[2];
        var contextDescription = arguments[3];

        switch (expr.type) {
          case "TSTypeCastExpression":
            return;

          case "TSParameterProperty":
            this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
            return;

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
            return;

          default:
            _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'checkLVal', this).call(this, expr, bindingType, checkClashes, contextDescription);
            return;
        }
      }
    }, {
      key: 'parseBindingAtom',
      value: function parseBindingAtom() {
        switch (this.state.type) {
          case types._this:
            return this.parseIdentifier(true);

          default:
            return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseBindingAtom', this).call(this);
        }
      }
    }, {
      key: 'parseMaybeDecoratorArguments',
      value: function parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          var typeArguments = this.tsParseTypeArguments();

          if (this.match(types.parenL)) {
            var call = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeDecoratorArguments', this).call(this, expr);
            call.typeParameters = typeArguments;
            return call;
          }

          this.unexpected(this.state.start, types.parenL);
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeDecoratorArguments', this).call(this, expr);
      }
    }, {
      key: 'isClassMethod',
      value: function isClassMethod() {
        return this.isRelational("<") || _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'isClassMethod', this).call(this);
      }
    }, {
      key: 'isClassProperty',
      value: function isClassProperty() {
        return this.match(types.bang) || this.match(types.colon) || _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'isClassProperty', this).call(this);
      }
    }, {
      key: 'parseMaybeDefault',
      value: function parseMaybeDefault() {
        var _get7;

        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        var node = (_get7 = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'parseMaybeDefault', this)).call.apply(_get7, [this].concat(args));

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
        }

        return node;
      }
    }, {
      key: 'getTokenFromCode',
      value: function getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else {
          return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'getTokenFromCode', this).call(this, code);
        }
      }
    }, {
      key: 'toAssignableList',
      value: function toAssignableList(exprList, isBinding) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (!expr) continue;

          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;

            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!isBinding) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, "Unexpected type cast in parameter position.");
              }

              break;
          }
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'toAssignableList', this).apply(this, arguments);
      }
    }, {
      key: 'typeCastToParameter',
      value: function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      }
    }, {
      key: 'toReferencedList',
      value: function toReferencedList(exprList, isInParens) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr._exprListItem && expr.type === "TsTypeCastExpression") {
            this.raise(expr.start, "Did not expect a type annotation here.");
          }
        }

        return exprList;
      }
    }, {
      key: 'shouldParseArrow',
      value: function shouldParseArrow() {
        return this.match(types.colon) || _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'shouldParseArrow', this).call(this);
      }
    }, {
      key: 'shouldParseAsyncArrow',
      value: function shouldParseAsyncArrow() {
        return this.match(types.colon) || _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'shouldParseAsyncArrow', this).call(this);
      }
    }, {
      key: 'canHaveLeadingDecorator',
      value: function canHaveLeadingDecorator() {
        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'canHaveLeadingDecorator', this).call(this) || this.isAbstractClass();
      }
    }, {
      key: 'jsxParseOpeningElementAfterName',
      value: function jsxParseOpeningElementAfterName(node) {
        var _this37 = this;

        if (this.isRelational("<")) {
          var typeArguments = this.tsTryParseAndCatch(function () {
            return _this37.tsParseTypeArguments();
          });
          if (typeArguments) node.typeParameters = typeArguments;
        }

        return _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'jsxParseOpeningElementAfterName', this).call(this, node);
      }
    }, {
      key: 'getGetterSetterExpectedParamCount',
      value: function getGetterSetterExpectedParamCount(method) {
        var baseCount = _get(_class4.prototype.__proto__ || Object.getPrototypeOf(_class4.prototype), 'getGetterSetterExpectedParamCount', this).call(this, method);
        var firstParam = method.params[0];
        var hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
        return hasContextParam ? baseCount + 1 : baseCount;
      }
    }]);

    return _class4;
  }(superClass);
};

types.placeholder = new TokenType("%%", {
  startsExpr: true
});
var placeholders = function placeholders(superClass) {
  return function (_superClass5) {
    _inherits(_class5, _superClass5);

    function _class5() {
      _classCallCheck(this, _class5);

      return _possibleConstructorReturn(this, (_class5.__proto__ || Object.getPrototypeOf(_class5)).apply(this, arguments));
    }

    _createClass(_class5, [{
      key: 'parsePlaceholder',
      value: function parsePlaceholder(expectedNode) {
        if (this.match(types.placeholder)) {
          var node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseIdentifier', this).call(this, true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(types.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
    }, {
      key: 'finishPlaceholder',
      value: function finishPlaceholder(node, expectedNode) {
        var isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      }
    }, {
      key: 'getTokenFromCode',
      value: function getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types.placeholder, 2);
        }

        return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'getTokenFromCode', this).apply(this, arguments);
      }
    }, {
      key: 'parseExprAtom',
      value: function parseExprAtom() {
        return this.parsePlaceholder("Expression") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseExprAtom', this).apply(this, arguments);
      }
    }, {
      key: 'parseIdentifier',
      value: function parseIdentifier() {
        return this.parsePlaceholder("Identifier") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseIdentifier', this).apply(this, arguments);
      }
    }, {
      key: 'checkReservedWord',
      value: function checkReservedWord(word) {
        if (word !== undefined) _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'checkReservedWord', this).apply(this, arguments);
      }
    }, {
      key: 'parseBindingAtom',
      value: function parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseBindingAtom', this).apply(this, arguments);
      }
    }, {
      key: 'checkLVal',
      value: function checkLVal(expr) {
        if (expr.type !== "Placeholder") _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'checkLVal', this).apply(this, arguments);
      }
    }, {
      key: 'toAssignable',
      value: function toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }

        return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'toAssignable', this).apply(this, arguments);
      }
    }, {
      key: 'verifyBreakContinue',
      value: function verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder") return;
        _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'verifyBreakContinue', this).apply(this, arguments);
      }
    }, {
      key: 'parseExpressionStatement',
      value: function parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseExpressionStatement', this).apply(this, arguments);
        }

        if (this.match(types.colon)) {
          var stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }

        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      }
    }, {
      key: 'parseBlock',
      value: function parseBlock() {
        return this.parsePlaceholder("BlockStatement") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseBlock', this).apply(this, arguments);
      }
    }, {
      key: 'parseFunctionId',
      value: function parseFunctionId() {
        return this.parsePlaceholder("Identifier") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseFunctionId', this).apply(this, arguments);
      }
    }, {
      key: 'parseClass',
      value: function parseClass(node, isStatement, optionalId) {
        var type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        var placeholder = this.parsePlaceholder("Identifier");

        if (placeholder) {
          if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, "A class name is required");
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }

        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass);
        return this.finishNode(node, type);
      }
    }, {
      key: 'parseExport',
      value: function parseExport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseExport', this).apply(this, arguments);

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }

        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseExport', this).call(this, node);
      }
    }, {
      key: 'maybeParseExportDefaultSpecifier',
      value: function maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }

        return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'maybeParseExportDefaultSpecifier', this).apply(this, arguments);
      }
    }, {
      key: 'checkExport',
      value: function checkExport(node) {
        var specifiers = node.specifiers;


        if (specifiers && specifiers.length) {
          node.specifiers = specifiers.filter(function (node) {
            return node.exported.type === "Placeholder";
          });
        }

        _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'checkExport', this).call(this, node);
        node.specifiers = specifiers;
      }
    }, {
      key: 'parseImport',
      value: function parseImport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseImport', this).apply(this, arguments);
        node.specifiers = [];

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }

        var specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);

        if (this.eat(types.comma)) {
          var hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }

        this.expectContextual("from");
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
    }, {
      key: 'parseImportSource',
      value: function parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || _get(_class5.prototype.__proto__ || Object.getPrototypeOf(_class5.prototype), 'parseImportSource', this).apply(this, arguments);
      }
    }]);

    return _class5;
  }(superClass);
};

var v8intrinsic = function v8intrinsic(superClass) {
  return function (_superClass6) {
    _inherits(_class6, _superClass6);

    function _class6() {
      _classCallCheck(this, _class6);

      return _possibleConstructorReturn(this, (_class6.__proto__ || Object.getPrototypeOf(_class6)).apply(this, arguments));
    }

    _createClass(_class6, [{
      key: 'parseV8Intrinsic',
      value: function parseV8Intrinsic() {
        if (this.match(types.modulo)) {
          var v8IntrinsicStart = this.state.start;
          var node = this.startNode();
          this.eat(types.modulo);

          if (this.match(types.name)) {
            var name = this.parseIdentifierName(this.state.start);
            var identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";

            if (this.match(types.parenL)) {
              return identifier;
            }
          }

          this.unexpected(v8IntrinsicStart);
        }
      }
    }, {
      key: 'parseExprAtom',
      value: function parseExprAtom() {
        return this.parseV8Intrinsic() || _get(_class6.prototype.__proto__ || Object.getPrototypeOf(_class6.prototype), 'parseExprAtom', this).apply(this, arguments);
      }
    }]);

    return _class6;
  }(superClass);
};

function hasPlugin(plugins, name) {
  return plugins.some(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}
function getPluginOption(plugins, name, option) {
  var plugin = plugins.find(function (plugin) {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }

  return null;
}
var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport == null) {
      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
    throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
      return '\'' + p + '\'';
    }).join(", "));
  }
}
var mixinPlugins = {
  estree: estree,
  jsx: jsx,
  flow: flow,
  typescript: typescript,
  v8intrinsic: v8intrinsic,
  placeholders: placeholders
};
var mixinPluginNames = Object.keys(mixinPlugins);

var defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false
};
function getOptions(opts) {
  var options = {};

  for (var _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

var Position = function Position(line, col) {
  _classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

function getLineInfo(input, offset) {
  var line = 1;
  var lineStart = 0;
  var match = void 0;
  lineBreakG.lastIndex = 0;

  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }

  return new Position(line, offset - lineStart);
}

var BaseParser = function () {
  function BaseParser() {
    _classCallCheck(this, BaseParser);

    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  _createClass(BaseParser, [{
    key: 'hasPlugin',
    value: function hasPlugin(name) {
      return this.plugins.has(name);
    }
  }, {
    key: 'getPluginOption',
    value: function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }
  }]);

  return BaseParser;
}();

function last(stack) {
  return stack[stack.length - 1];
}

var CommentsParser = function (_BaseParser) {
  _inherits(CommentsParser, _BaseParser);

  function CommentsParser() {
    _classCallCheck(this, CommentsParser);

    return _possibleConstructorReturn(this, (CommentsParser.__proto__ || Object.getPrototypeOf(CommentsParser)).apply(this, arguments));
  }

  _createClass(CommentsParser, [{
    key: 'addComment',
    value: function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    }
  }, {
    key: 'adjustCommentsAfterTrailingComma',
    value: function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      var lastElement = null;
      var i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (var j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      var newTrailingComments = [];

      for (var _i7 = 0; _i7 < this.state.leadingComments.length; _i7++) {
        var leadingComment = this.state.leadingComments[_i7];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(_i7, 1);
            _i7--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    }
  }, {
    key: 'processComment',
    value: function processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      var stack = this.state.commentStack;
      var firstChild = void 0,
          lastChild = void 0,
          trailingComments = void 0,
          i = void 0,
          j = void 0;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        var lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode], true);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          var leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          node.trailingComments = trailingComments;
        }
      }

      stack.push(node);
    }
  }]);

  return CommentsParser;
}(BaseParser);

var LocationParser = function (_CommentsParser) {
  _inherits(LocationParser, _CommentsParser);

  function LocationParser() {
    _classCallCheck(this, LocationParser);

    return _possibleConstructorReturn(this, (LocationParser.__proto__ || Object.getPrototypeOf(LocationParser)).apply(this, arguments));
  }

  _createClass(LocationParser, [{
    key: 'getLocationForPosition',
    value: function getLocationForPosition(pos) {
      var loc = void 0;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    }
  }, {
    key: 'raise',
    value: function raise(pos, message) {
      var _ref16 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          missingPluginNames = _ref16.missingPluginNames,
          code = _ref16.code;

      var loc = this.getLocationForPosition(pos);
      message += ' (' + loc.line + ':' + loc.column + ')';
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;

      if (missingPluginNames) {
        err.missingPlugin = missingPluginNames;
      }

      if (code !== undefined) {
        err.code = code;
      }

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }
  }]);

  return LocationParser;
}(CommentsParser);

var State = function () {
  function State() {
    _classCallCheck(this, State);

    this.errors = [];
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.inParameters = false;
    this.maybeInArrowParameters = false;
    this.inPipeline = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.inPropertyName = false;
    this.inClassProperty = false;
    this.hasFlowComment = false;
    this.isIterator = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.soloAwait = false;
    this.inFSharpPipelineDirectBody = false;
    this.classLevel = 0;
    this.labels = [];
    this.decoratorStack = [[]];
    this.yieldPos = -1;
    this.awaitPos = -1;
    this.tokens = [];
    this.comments = [];
    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];
    this.commentPreviousNode = null;
    this.pos = 0;
    this.lineStart = 0;
    this.type = types.eof;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.lastTokEnd = 0;
    this.context = [types$1.braceStatement];
    this.exprAllowed = true;
    this.containsEsc = false;
    this.containsOctal = false;
    this.octalPosition = null;
    this.exportedIdentifiers = [];
    this.invalidTemplateEscapePosition = null;
  }

  _createClass(State, [{
    key: 'init',
    value: function init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }
  }, {
    key: 'curPosition',
    value: function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  }, {
    key: 'clone',
    value: function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }
  }]);

  return State;
}();

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};
var VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
var forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
var allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.bin), [50, 51, 52, 53, 54, 55]);
allowedNumericSeparatorSiblings.dec = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.oct), [56, 57]);
allowedNumericSeparatorSiblings.hex = [].concat(_toConsumableArray(allowedNumericSeparatorSiblings.dec), [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);

var Token = function Token(state) {
  _classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

var Tokenizer = function (_LocationParser) {
  _inherits(Tokenizer, _LocationParser);

  function Tokenizer(options, input) {
    _classCallCheck(this, Tokenizer);

    var _this42 = _possibleConstructorReturn(this, (Tokenizer.__proto__ || Object.getPrototypeOf(Tokenizer)).call(this));

    _this42.state = new State();
    _this42.state.init(options);
    _this42.input = input;
    _this42.length = input.length;
    _this42.isLookahead = false;
    return _this42;
  }

  _createClass(Tokenizer, [{
    key: 'next',
    value: function next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.state.tokens.push(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
  }, {
    key: 'eat',
    value: function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'match',
    value: function match(type) {
      return this.state.type === type;
    }
  }, {
    key: 'lookahead',
    value: function lookahead() {
      var old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    }
  }, {
    key: 'nextTokenStart',
    value: function nextTokenStart() {
      var thisTokEnd = this.state.pos;
      skipWhiteSpace.lastIndex = thisTokEnd;
      var skip = skipWhiteSpace.exec(this.input);
      return thisTokEnd + skip[0].length;
    }
  }, {
    key: 'lookaheadCharCode',
    value: function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
  }, {
    key: 'setStrict',
    value: function setStrict(strict) {
      this.state.strict = strict;
      if (!this.match(types.num) && !this.match(types.string)) return;
      this.state.pos = this.state.start;

      while (this.state.pos < this.state.lineStart) {
        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
        --this.state.curLine;
      }

      this.nextToken();
    }
  }, {
    key: 'curContext',
    value: function curContext() {
      return this.state.context[this.state.context.length - 1];
    }
  }, {
    key: 'nextToken',
    value: function nextToken() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) this.skipSpace();
      this.state.containsOctal = false;
      this.state.octalPosition = null;
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      if (curContext.override) {
        curContext.override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    }
  }, {
    key: 'pushComment',
    value: function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  }, {
    key: 'skipBlockComment',
    value: function skipBlockComment() {
      var startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, "Unterminated comment");
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      var match = void 0;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    }
  }, {
    key: 'skipLineComment',
    value: function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    }
  }, {
    key: 'skipSpace',
    value: function skipSpace() {
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    }
  }, {
    key: 'finishToken',
    value: function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    }
  }, {
    key: 'readToken_numberSign',
    value: function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, "Unexpected digit after hash token");
      }

      if ((this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods")) && this.state.classLevel > 0) {
        ++this.state.pos;
        this.finishToken(types.hash);
        return;
      } else if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        this.finishOp(types.hash, 1);
      } else {
        throw this.raise(this.state.pos, "Unexpected character '#'");
      }
    }
  }, {
    key: 'readToken_dot',
    value: function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    }
  }, {
    key: 'readToken_slash',
    value: function readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    }
  }, {
    key: 'readToken_interpreter',
    value: function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var start = this.state.pos;
      this.state.pos += 1;
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch !== 33) return false;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    }
  }, {
    key: 'readToken_mult_modulo',
    value: function readToken_mult_modulo(code) {
      var type = code === 42 ? types.star : types.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      var exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    }
  }, {
    key: 'readToken_pipe_amp',
    value: function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    }
  }, {
    key: 'readToken_caret',
    value: function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    }
  }, {
    key: 'readToken_plus_min',
    value: function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    }
  }, {
    key: 'readToken_lt_gt',
    value: function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    }
  }, {
    key: 'readToken_eq_excl',
    value: function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    }
  }, {
    key: 'readToken_question',
    value: function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63 && !this.state.inType) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    }
  }, {
    key: 'getTokenFromCode',
    value: function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          ++this.state.pos;
          this.finishToken(types.bracketL);
          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          ++this.state.pos;
          this.finishToken(types.braceL);
          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }

      }

      throw this.raise(this.state.pos, 'Unexpected character \'' + String.fromCodePoint(code) + '\'');
    }
  }, {
    key: 'finishOp',
    value: function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
  }, {
    key: 'readRegexp',
    value: function readRegexp() {
      var start = this.state.pos;
      var escaped = void 0,
          inClass = void 0;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, "Unterminated regular expression");
        }

        var ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, "Unterminated regular expression");
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }

          escaped = ch === "\\";
        }

        ++this.state.pos;
      }

      var content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      var mods = "";

      while (this.state.pos < this.length) {
        var char = this.input[this.state.pos];
        var charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(char)) {
          if (mods.indexOf(char) > -1) {
            this.raise(this.state.pos + 1, "Duplicate regular expression flag");
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, "Invalid regular expression flag");
        } else {
          break;
        }

        ++this.state.pos;
        mods += char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    }
  }, {
    key: 'readInt',
    value: function readInt(radix, len, forceLen) {
      var allowNumSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (this.hasPlugin("numericSeparator")) {
          if (code === 95) {
            var prev = this.input.charCodeAt(this.state.pos - 1);
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (allowedSiblings.indexOf(next) === -1) {
              this.raise(this.state.pos, "A numeric separator is only allowed between two digits");
            } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
              this.raise(this.state.pos, "A numeric separator is only allowed between two digits");
            }

            if (!allowNumSeparator) {
              this.raise(this.state.pos, "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences");
            }

            ++this.state.pos;
            continue;
          }
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, "Expected number in radix " + radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    }
  }, {
    key: 'readRadixNumber',
    value: function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, "Expected number in radix " + radix);
      }

      if (this.hasPlugin("bigInt")) {
        if (this.input.charCodeAt(this.state.pos) === 110) {
          ++this.state.pos;
          isBigInt = true;
        }
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, "Identifier directly after number");
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    }
  }, {
    key: 'readNumber',
    value: function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isNonOctalDecimalInt = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, "Invalid number");
      }

      var octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (octal) {
        if (this.state.strict) {
          this.raise(start, "Legacy octal literals are not allowed in strict mode");
        }

        if (/[89]/.test(this.input.slice(start, this.state.pos))) {
          octal = false;
          isNonOctalDecimalInt = true;
        }
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !octal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) this.raise(start, "Invalid number");
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
        var underscorePos = this.input.slice(start, this.state.pos).indexOf("_");

        if (underscorePos > 0) {
          this.raise(underscorePos + start, "Numeric separator can not be used after leading 0");
        }
      }

      if (this.hasPlugin("bigInt")) {
        if (next === 110) {
          if (isFloat || octal || isNonOctalDecimalInt) {
            this.raise(start, "Invalid BigIntLiteral");
          }

          ++this.state.pos;
          isBigInt = true;
        }
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, "Identifier directly after number");
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      var val = octal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    }
  }, {
    key: 'readCodePoint',
    value: function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code = void 0;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code === null) {
          --this.state.invalidTemplateEscapePosition;
        } else if (code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, "Code point out of bounds");
          } else {
            this.state.invalidTemplateEscapePosition = codePos - 2;
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }
  }, {
    key: 'readString',
    value: function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, "Unterminated string constant");
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, "Unterminated string constant");
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    }
  }, {
    key: 'readTmplToken',
    value: function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, "Unterminated template");
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }
  }, {
    key: 'readEscapedChar',
    value: function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);
            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return '\x0B';

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            var codePos = this.state.pos - 1;
            this.state.invalidTemplateEscapePosition = codePos;
            return null;
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var _codePos = this.state.pos - 1;
            var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                this.state.invalidTemplateEscapePosition = _codePos;
                return null;
              } else if (this.state.strict) {
                this.raise(_codePos, "Octal literal in strict mode");
              } else if (!this.state.containsOctal) {
                this.state.containsOctal = true;
                this.state.octalPosition = _codePos;
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }
  }, {
    key: 'readHexChar',
    value: function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, "Bad character escape sequence");
        } else {
          this.state.pos = codePos - 1;
          this.state.invalidTemplateEscapePosition = codePos - 1;
        }
      }

      return n;
    }
  }, {
    key: 'readWord1',
    value: function readWord1() {
      var word = "";
      this.state.containsEsc = false;
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        var ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, 'Expecting Unicode escape sequence \\uXXXX');
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, "Invalid Unicode escape");
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }
  }, {
    key: 'isIterator',
    value: function isIterator(word) {
      return word === "@@iterator" || word === "@@asyncIterator";
    }
  }, {
    key: 'readWord',
    value: function readWord() {
      var word = this.readWord1();
      var type = keywords.get(word) || types.name;

      if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
        this.raise(this.state.pos, 'Invalid identifier ' + word);
      }

      this.finishToken(type, word);
    }
  }, {
    key: 'checkKeywordEscapes',
    value: function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, 'Escape sequence in keyword ' + kw);
      }
    }
  }, {
    key: 'braceIsBlock',
    value: function braceIsBlock(prevType) {
      var parent = this.curContext();

      if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
        return true;
      }

      if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
        return !parent.isExpr;
      }

      if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      }

      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    }
  }, {
    key: 'updateContext',
    value: function updateContext(prevType) {
      var type = this.state.type;
      var update = void 0;

      if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }
  }]);

  return Tokenizer;
}(LocationParser);

var literal = /^('|")((?:\\?.)*?)\1/;

var UtilParser = function (_Tokenizer) {
  _inherits(UtilParser, _Tokenizer);

  function UtilParser() {
    _classCallCheck(this, UtilParser);

    return _possibleConstructorReturn(this, (UtilParser.__proto__ || Object.getPrototypeOf(UtilParser)).apply(this, arguments));
  }

  _createClass(UtilParser, [{
    key: 'addExtra',
    value: function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    }
  }, {
    key: 'isRelational',
    value: function isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    }
  }, {
    key: 'isLookaheadRelational',
    value: function isLookaheadRelational(op) {
      var next = this.nextTokenStart();

      if (this.input.charAt(next) === op) {
        if (next + 1 === this.input.length) {
          return true;
        }

        var afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== op.charCodeAt(0) && afterNext !== 61;
      }

      return false;
    }
  }, {
    key: 'expectRelational',
    value: function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    }
  }, {
    key: 'eatRelational',
    value: function eatRelational(op) {
      if (this.isRelational(op)) {
        this.next();
        return true;
      }

      return false;
    }
  }, {
    key: 'isContextual',
    value: function isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    }
  }, {
    key: 'isUnparsedContextual',
    value: function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    }
  }, {
    key: 'isLookaheadContextual',
    value: function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
  }, {
    key: 'eatContextual',
    value: function eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    }
  }, {
    key: 'expectContextual',
    value: function expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    }
  }, {
    key: 'canInsertSemicolon',
    value: function canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    }
  }, {
    key: 'hasPrecedingLineBreak',
    value: function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
  }, {
    key: 'isLineTerminator',
    value: function isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    }
  }, {
    key: 'semicolon',
    value: function semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, types.semi);
    }
  }, {
    key: 'expect',
    value: function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
  }, {
    key: 'assertNoSpace',
    value: function assertNoSpace() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected space.";

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    }
  }, {
    key: 'unexpected',
    value: function unexpected(pos) {
      var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

      if (typeof messageOrType !== "string") {
        messageOrType = 'Unexpected token, expected "' + messageOrType.label + '"';
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }
  }, {
    key: 'expectPlugin',
    value: function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raise(pos != null ? pos : this.state.start, 'This experimental syntax requires enabling the parser plugin: \'' + name + '\'', {
          missingPluginNames: [name]
        });
      }

      return true;
    }
  }, {
    key: 'expectOnePlugin',
    value: function expectOnePlugin(names, pos) {
      var _this44 = this;

      if (!names.some(function (n) {
        return _this44.hasPlugin(n);
      })) {
        throw this.raise(pos != null ? pos : this.state.start, 'This experimental syntax requires enabling one of the following parser plugin(s): \'' + names.join(", ") + '\'', {
          missingPluginNames: names
        });
      }
    }
  }, {
    key: 'checkYieldAwaitInDefaultParams',
    value: function checkYieldAwaitInDefaultParams() {
      if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
        this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
      }

      if (this.state.awaitPos !== -1) {
        this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
      }
    }
  }, {
    key: 'strictDirective',
    value: function strictDirective(start) {
      for (;;) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) break;
        if (match[2] === "use strict") return true;
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;

        if (this.input[start] === ";") {
          start++;
        }
      }

      return false;
    }
  }, {
    key: 'tryParse',
    value: function tryParse(fn) {
      var oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();

      var abortSignal = {
        node: null
      };

      try {
        var node = fn(function () {
          var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    }
  }]);

  return UtilParser;
}(Tokenizer);

var Node = function () {
  function Node(parser, pos, loc) {
    _classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser && parser.options.ranges) this.range = [pos, 0];
    if (parser && parser.filename) this.loc.filename = parser.filename;
  }

  _createClass(Node, [{
    key: '__clone',
    value: function __clone() {
      var newNode = new Node();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];

        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }

      return newNode;
    }
  }]);

  return Node;
}();

var NodeUtils = function (_UtilParser) {
  _inherits(NodeUtils, _UtilParser);

  function NodeUtils() {
    _classCallCheck(this, NodeUtils);

    return _possibleConstructorReturn(this, (NodeUtils.__proto__ || Object.getPrototypeOf(NodeUtils)).apply(this, arguments));
  }

  _createClass(NodeUtils, [{
    key: 'startNode',
    value: function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
  }, {
    key: 'startNodeAt',
    value: function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
  }, {
    key: 'startNodeAtNode',
    value: function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
  }, {
    key: 'finishNode',
    value: function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
  }, {
    key: 'finishNodeAt',
    value: function finishNodeAt(node, type, pos, loc) {

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    }
  }, {
    key: 'resetStartLocation',
    value: function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }
  }, {
    key: 'resetEndLocation',
    value: function resetEndLocation(node) {
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEnd;
      var endLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.lastTokEndLoc;

      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }
  }, {
    key: 'resetStartLocationFromNode',
    value: function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  }]);

  return NodeUtils;
}(UtilParser);

var LValParser = function (_NodeUtils) {
  _inherits(LValParser, _NodeUtils);

  function LValParser() {
    _classCallCheck(this, LValParser);

    return _possibleConstructorReturn(this, (LValParser.__proto__ || Object.getPrototypeOf(LValParser)).apply(this, arguments));
  }

  _createClass(LValParser, [{
    key: 'toAssignable',
    value: function toAssignable(node, isBinding, contextDescription) {
      var _node$extra2;

      if (node) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;

          case "ObjectExpression":
            node.type = "ObjectPattern";

            for (var i = 0, length = node.properties.length, _last2 = length - 1; i < length; i++) {
              var _node$extra;

              var prop = node.properties[i];
              var isLast = i === _last2;
              this.toAssignableObjectExpressionProp(prop, isBinding, isLast);

              if (isLast && prop.type === "RestElement" && ((_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma)) {
                this.raiseRestNotLast(node.extra.trailingComma);
              }
            }

            break;

          case "ObjectProperty":
            this.toAssignable(node.value, isBinding, contextDescription);
            break;

          case "SpreadElement":
            {
              this.checkToRestConversion(node);
              node.type = "RestElement";
              var arg = node.argument;
              this.toAssignable(arg, isBinding, contextDescription);
              break;
            }

          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, isBinding, contextDescription, (_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma);
            break;

          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }

            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding, contextDescription);
            break;

          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
            break;

          case "MemberExpression":
            if (!isBinding) break;

          default:
        }
      }

      return node;
    }
  }, {
    key: 'toAssignableObjectExpressionProp',
    value: function toAssignableObjectExpressionProp(prop, isBinding, isLast) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? "Object pattern can't contain getter or setter" : "Object pattern can't contain methods";
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isBinding, "object destructuring pattern");
      }
    }
  }, {
    key: 'toAssignableList',
    value: function toAssignableList(exprList, isBinding, contextDescription, trailingCommaPos) {
      var end = exprList.length;

      if (end) {
        var _last3 = exprList[end - 1];

        if (_last3 && _last3.type === "RestElement") {
          --end;
        } else if (_last3 && _last3.type === "SpreadElement") {
          _last3.type = "RestElement";
          var arg = _last3.argument;
          this.toAssignable(arg, isBinding, contextDescription);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isBinding, contextDescription);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }
  }, {
    key: 'toReferencedList',
    value: function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
  }, {
    key: 'toReferencedListDeep',
    value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (var _i = 0; _i < exprList.length; _i++) {
        var expr = exprList[_i];

        if (expr && expr.type === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }

      return exprList;
    }
  }, {
    key: 'parseSpread',
    value: function parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }
  }, {
    key: 'parseRestBinding',
    value: function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
  }, {
    key: 'parseBindingAtom',
    value: function parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types.braceL:
          return this.parseObj(true);
      }

      return this.parseIdentifier();
    }
  }, {
    key: 'parseBindingList',
    value: function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, "Stage 2 decorators cannot be used to decorate parameters");
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }
  }, {
    key: 'parseAssignableListItem',
    value: function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }
  }, {
    key: 'parseAssignableListItemTypes',
    value: function parseAssignableListItemTypes(param) {
      return param;
    }
  }, {
    key: 'parseMaybeDefault',
    value: function parseMaybeDefault(startPos, startLoc, left) {
      startLoc = startLoc || this.state.startLoc;
      startPos = startPos || this.state.start;
      left = left || this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    }
  }, {
    key: 'checkLVal',
    value: function checkLVal(expr) {
      var bindingType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BIND_NONE;
      var checkClashes = arguments[2];
      var contextDescription = arguments[3];
      var disallowLetBinding = arguments[4];
      var strictModeChanged = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      switch (expr.type) {
        case "Identifier":
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
            this.raise(expr.start, (bindingType === BIND_NONE ? "Assigning to" : "Binding") + ' \'' + expr.name + '\' in strict mode');
          }

          if (checkClashes) {
            var key = '_' + expr.name;

            if (checkClashes[key]) {
              this.raise(expr.start, "Argument name clash");
            } else {
              checkClashes[key] = true;
            }
          }

          if (disallowLetBinding && expr.name === "let") {
            this.raise(expr.start, "'let' is not allowed to be used as a name in 'let' or 'const' declarations.");
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(expr.name, bindingType, expr.start);
          }

          break;

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, "Binding member expression");
          }

          break;

        case "ObjectPattern":
          for (var _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
            var prop = _expr$properties[_i2];
            if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
            this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (var _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
            var elem = _expr$elements[_i3];

            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
          break;

        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
          break;

        default:
          {
            var message = (bindingType === BIND_NONE ? "Invalid" : "Binding invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
            this.raise(expr.start, message);
          }
      }
    }
  }, {
    key: 'checkToRestConversion',
    value: function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, "Invalid rest operator's argument");
      }
    }
  }, {
    key: 'checkCommaAfterRest',
    value: function checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }
  }, {
    key: 'raiseRestNotLast',
    value: function raiseRestNotLast(pos) {
      throw this.raise(pos, 'Rest element must be last element');
    }
  }, {
    key: 'raiseTrailingCommaAfterRest',
    value: function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, 'Unexpected trailing comma after rest element');
    }
  }]);

  return LValParser;
}(NodeUtils);

var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

var ExpressionParser = function (_LValParser) {
  _inherits(ExpressionParser, _LValParser);

  function ExpressionParser() {
    _classCallCheck(this, ExpressionParser);

    return _possibleConstructorReturn(this, (ExpressionParser.__proto__ || Object.getPrototypeOf(ExpressionParser)).apply(this, arguments));
  }

  _createClass(ExpressionParser, [{
    key: 'checkDuplicatedProto',
    value: function checkDuplicatedProto(prop, protoRef) {
      if (prop.type === "SpreadElement" || prop.computed || prop.kind || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (protoRef.used && !protoRef.start) {
          protoRef.start = key.start;
        }

        protoRef.used = true;
      }
    }
  }, {
    key: 'getExpression',
    value: function getExpression() {
      this.scope.enter(SCOPE_PROGRAM);
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      return expr;
    }
  }, {
    key: 'parseExpression',
    value: function parseExpression(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);

      if (this.match(types.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }
  }, {
    key: 'parseMaybeAssign',
    value: function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.scope.inGenerator) {
          var _left = this.parseYield(noIn);

          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startPos, startLoc);
          }

          return _left;
        } else {
          this.state.exprAllowed = false;
        }
      }

      var failOnShorthandAssign = void 0;

      if (refShorthandDefaultPos) {
        failOnShorthandAssign = false;
      } else {
        refShorthandDefaultPos = {
          start: 0
        };
        failOnShorthandAssign = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (operator === "??=") {
          this.expectPlugin("nullishCoalescingOperator");
          this.expectPlugin("logicalAssignment");
        }

        if (operator === "||=" || operator === "&&=") {
          this.expectPlugin("logicalAssignment");
        }

        node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;

        if (refShorthandDefaultPos.start >= node.left.start) {
          refShorthandDefaultPos.start = 0;
        }

        this.checkLVal(left, undefined, undefined, "assignment expression");
        var maybePattern = unwrapParenthesizedExpression(left);
        var patternErrorMsg = void 0;

        if (maybePattern.type === "ObjectPattern") {
          patternErrorMsg = "`({a}) = 0` use `({a} = 0)`";
        } else if (maybePattern.type === "ArrayPattern") {
          patternErrorMsg = "`([a]) = 0` use `([a] = 0)`";
        }

        if (patternErrorMsg && (left.extra && left.extra.parenthesized || left.type === "ParenthesizedExpression")) {
          this.raise(maybePattern.start, 'You\'re trying to assign to a parenthesized expression, eg. instead of ' + patternErrorMsg);
        }

        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      return left;
    }
  }, {
    key: 'parseMaybeConditional',
    value: function parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(noIn, refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
      return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    }
  }, {
    key: 'parseConditional',
    value: function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }
  }, {
    key: 'parseExprOps',
    value: function parseExprOps(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    }
  }, {
    key: 'parseExprOp',
    value: function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.state.type.binop;

      if (prec != null && (!noIn || !this.match(types._in))) {
        if (prec > minPrec) {
          var operator = this.state.value;

          if (operator === "|>" && this.state.inFSharpPipelineDirectBody) {
            return left;
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = operator;

          if (operator === "**" && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
            this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
          }

          var op = this.state.type;

          if (op === types.pipeline) {
            this.expectPlugin("pipelineOperator");
            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          } else if (op === types.nullishCoalescing) {
            this.expectPlugin("nullishCoalescingOperator");
          }

          this.next();

          if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types.name) && this.state.value === "await" && this.scope.inAsync) {
              throw this.raise(this.state.start, 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal');
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec, noIn);

          if (op === types.nullishCoalescing) {
            if (left.type === "LogicalExpression" && left.operator !== "??" && !(left.extra && left.extra.parenthesized)) {
              throw this.raise(left.start, 'Nullish coalescing operator(??) requires parens when mixing with logical operators');
            } else if (node.right.type === "LogicalExpression" && node.right.operator !== "??" && !(node.right.extra && node.right.extra.parenthesized)) {
              throw this.raise(node.right.start, 'Nullish coalescing operator(??) requires parens when mixing with logical operators');
            }
          }

          this.finishNode(node, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }

      return left;
    }
  }, {
    key: 'parseExprOpRightExpr',
    value: function parseExprOpRightExpr(op, prec, noIn) {
      var _this48 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(function () {
                return _this48.parseSmartPipelineBody(_this48.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this48.parseFSharpPipelineBody(prec, noIn);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec, noIn);
      }
    }
  }, {
    key: 'parseExprOpBaseRightExpr',
    value: function parseExprOpBaseRightExpr(op, prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
    }
  }, {
    key: 'parseMaybeUnary',
    value: function parseMaybeUnary(refShorthandDefaultPos) {
      if (this.isContextual("await") && this.isAwaitAllowed()) {
        return this.parseAwait();
      } else if (this.state.type.prefix) {
        var node = this.startNode();
        var update = this.match(types.incDec);
        node.operator = this.state.value;
        node.prefix = true;

        if (node.operator === "throw") {
          this.expectPlugin("throwExpressions");
        }

        this.next();
        node.argument = this.parseMaybeUnary();

        if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
          this.unexpected(refShorthandDefaultPos.start);
        }

        if (update) {
          this.checkLVal(node.argument, undefined, undefined, "prefix operation");
        } else if (this.state.strict && node.operator === "delete") {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, "Deleting local variable in strict mode");
          } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
            this.raise(node.start, "Deleting a private field is not allowed");
          }
        }

        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node10 = this.startNodeAt(startPos, startLoc);
        _node10.operator = this.state.value;
        _node10.prefix = false;
        _node10.argument = expr;
        this.checkLVal(expr, undefined, undefined, "postfix operation");
        this.next();
        expr = this.finishNode(_node10, "UpdateExpression");
      }

      return expr;
    }
  }, {
    key: 'parseExprSubscripts',
    value: function parseExprSubscripts(refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refShorthandDefaultPos);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }
  }, {
    key: 'parseSubscripts',
    value: function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsync(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }
  }, {
    key: 'parseSubscript',
    value: function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      } else if (this.match(types.questionDot)) {
        this.expectPlugin("optionalChaining");
        state.optionalChainMember = true;

        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        this.next();
        var _node11 = this.startNodeAt(startPos, startLoc);

        if (this.eat(types.bracketL)) {
          _node11.object = base;
          _node11.property = this.parseExpression();
          _node11.computed = true;
          _node11.optional = true;
          this.expect(types.bracketR);
          return this.finishNode(_node11, "OptionalMemberExpression");
        } else if (this.eat(types.parenL)) {
          _node11.callee = base;
          _node11.arguments = this.parseCallExpressionArguments(types.parenR, false);
          _node11.optional = true;
          return this.finishCallExpression(_node11, true);
        } else {
          _node11.object = base;
          _node11.property = this.parseIdentifier(true);
          _node11.computed = false;
          _node11.optional = true;
          return this.finishNode(_node11, "OptionalMemberExpression");
        }
      } else if (this.eat(types.dot)) {
        var _node12 = this.startNodeAt(startPos, startLoc);
        _node12.object = base;
        _node12.property = this.parseMaybePrivateName();
        _node12.computed = false;

        if (_node12.property.type === "PrivateName" && _node12.object.type === "Super") {
          this.raise(startPos, "Private fields can't be accessed on super");
        }

        if (state.optionalChainMember) {
          _node12.optional = false;
          return this.finishNode(_node12, "OptionalMemberExpression");
        }

        return this.finishNode(_node12, "MemberExpression");
      } else if (this.eat(types.bracketL)) {
        var _node13 = this.startNodeAt(startPos, startLoc);
        _node13.object = base;
        _node13.property = this.parseExpression();
        _node13.computed = true;
        this.expect(types.bracketR);

        if (state.optionalChainMember) {
          _node13.optional = false;
          return this.finishNode(_node13, "OptionalMemberExpression");
        }

        return this.finishNode(_node13, "MemberExpression");
      } else if (!noCalls && this.match(types.parenL)) {
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = true;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.next();
        var _node14 = this.startNodeAt(startPos, startLoc);
        _node14.callee = base;
        _node14.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", _node14);
        this.finishCallExpression(_node14, state.optionalChainMember);

        if (state.maybeAsyncArrow && this.shouldParseAsyncArrow()) {
          state.stop = true;
          _node14 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node14);
          this.checkYieldAwaitInDefaultParams();
          this.state.yieldPos = oldYieldPos;
          this.state.awaitPos = oldAwaitPos;
        } else {
          this.toReferencedListDeep(_node14.arguments);
          if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

          if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
            this.state.awaitPos = oldAwaitPos;
          }
        }

        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return _node14;
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
      } else {
        state.stop = true;
        return base;
      }
    }
  }, {
    key: 'parseTaggedTemplateExpression',
    value: function parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (typeArguments) node.typeParameters = typeArguments;

      if (state.optionalChainMember) {
        this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain");
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }
  }, {
    key: 'atPossibleAsync',
    value: function atPossibleAsync(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    }
  }, {
    key: 'finishCallExpression',
    value: function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length !== 1) {
          this.raise(node.start, "import() requires exactly one argument");
        } else {
          var importArg = node.arguments[0];

          if (importArg && importArg.type === "SpreadElement") {
            this.raise(importArg.start, "... is not allowed in import()");
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
  }, {
    key: 'parseCallExpressionArguments',
    value: function parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      var elts = [];
      var innerParenStart = void 0;
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (dynamicImport) {
              this.raise(this.state.lastTokStart, "Trailing comma is disallowed inside import(...) arguments");
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        if (this.match(types.parenL) && !innerParenStart) {
          innerParenStart = this.state.start;
        }

        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {
          start: 0
        } : undefined, possibleAsyncArrow ? {
          start: 0
        } : undefined, allowPlaceholder));
      }

      if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
        this.unexpected();
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
  }, {
    key: 'shouldParseAsyncArrow',
    value: function shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    }
  }, {
    key: 'parseAsyncArrowFromCallExpression',
    value: function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    }
  }, {
    key: 'parseNoCallExpr',
    value: function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
  }, {
    key: 'parseExprAtom',
    value: function parseExprAtom(refShorthandDefaultPos) {
      if (this.state.type === types.slash) this.readRegexp();
      var canBeArrow = this.state.potentialArrowAt === this.state.start;
      var node = void 0;

      switch (this.state.type) {
        case types._super:
          node = this.startNode();
          this.next();

          if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, "super() is only valid inside a class constructor of a subclass. " + "Maybe a typo in the method name ('constructor') or not extending another class?");
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, "super is only allowed in object methods and classes");
          }

          if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
            this.raise(node.start, "super can only be used with function calls (i.e. super()) or " + "in property accesses (i.e. super.prop or super[prop])");
          }

          return this.finishNode(node, "Super");

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          this.expectPlugin("dynamicImport", node.start);

          if (!this.match(types.parenL)) {
            this.unexpected(null, types.parenL);
          }

          return this.finishNode(node, "Import");

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types.name:
          {
            node = this.startNode();
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseFunction(node, undefined, true);
            } else if (canBeArrow && !containsEsc && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
              var params = [this.parseIdentifier()];
              this.expect(types.arrow);
              this.parseArrowExpression(node, params, true);
              return node;
            }

            if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
              this.next();
              this.parseArrowExpression(node, [id], false);
              return node;
            }

            return id;
          }

        case types._do:
          {
            this.expectPlugin("doExpressions");
            var _node15 = this.startNode();
            this.next();
            var oldLabels = this.state.labels;
            this.state.labels = [];
            _node15.body = this.parseBlock();
            this.state.labels = oldLabels;
            return this.finishNode(_node15, "DoExpression");
          }

        case types.regexp:
          {
            var value = this.state.value;
            node = this.parseLiteral(value.value, "RegExpLiteral");
            node.pattern = value.pattern;
            node.flags = value.flags;
            return node;
          }

        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketL:
          {
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos, node);

            if (!this.state.maybeInArrowParameters) {
              this.toReferencedList(node.elements);
            }

            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return this.finishNode(node, "ArrayExpression");
          }

        case types.braceL:
          {
            var _oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            var ret = this.parseObj(false, refShorthandDefaultPos);
            this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody;
            return ret;
          }

        case types._function:
          return this.parseFunctionExpression();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNew();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, "Binding should be performed on object property.");
            }
          }

        case types.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.");
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, 'Topic reference was used in a lexical context without topic binding');
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }
          }

        default:
          throw this.unexpected();
      }
    }
  }, {
    key: 'parseBooleanLiteral',
    value: function parseBooleanLiteral() {
      var node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
  }, {
    key: 'parseMaybePrivateName',
    value: function parseMaybePrivateName() {
      var isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);
        var node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space between # and identifier");
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, "PrivateName");
      } else {
        return this.parseIdentifier(true);
      }
    }
  }, {
    key: 'parseFunctionExpression',
    value: function parseFunctionExpression() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "function");

      if (this.scope.inGenerator && this.eat(types.dot)) {
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }
  }, {
    key: 'parseMetaProperty',
    value: function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, 'The only valid meta property for ' + meta.name + ' is ' + meta.name + '.' + propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    }
  }, {
    key: 'parseImportMetaProperty',
    value: function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.expect(types.dot);

      if (this.isContextual("meta")) {
        this.expectPlugin("importMeta");

        if (!this.inModule) {
          this.raise(id.start, 'import.meta may appear only with \'sourceType: "module"\'', {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          });
        }

        this.sawUnambiguousESM = true;
      } else if (!this.hasPlugin("importMeta")) {
        this.raise(id.start, 'Dynamic imports require a parameter: import(\'a.js\')');
      }

      return this.parseMetaProperty(node, id, "meta");
    }
  }, {
    key: 'parseLiteral',
    value: function parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
  }, {
    key: 'parseParenAndDistinguishExpression',
    value: function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val = void 0;
      this.expect(types.parenL);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refShorthandDefaultPos = {
        start: 0
      };
      var refNeedsArrowPos = {
        start: 0
      };
      var first = true;
      var spreadStart = void 0;
      var optionalCommaStart = void 0;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
        }
      }

      var innerEndPos = this.state.start;
      var innerEndLoc = this.state.startLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;

        for (var _i = 0; _i < exprList.length; _i++) {
          var param = exprList[_i];

          if (param.extra && param.extra.parenthesized) {
            this.unexpected(param.extra.parenStart);
          }
        }

        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
      if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);

      if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }
  }, {
    key: 'shouldParseArrow',
    value: function shouldParseArrow() {
      return !this.canInsertSemicolon();
    }
  }, {
    key: 'parseArrow',
    value: function parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    }
  }, {
    key: 'parseParenItem',
    value: function parseParenItem(node, startPos, startLoc) {
      return node;
    }
  }, {
    key: 'parseNew',
    value: function parseNew() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "new");

      if (this.eat(types.dot)) {
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.state.inClassProperty) {
          var error = "new.target can only be used in functions";

          if (this.hasPlugin("classProperties")) {
            error += " or class properties";
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, "Cannot use new with import(...)");
      } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
        this.raise(this.state.lastTokEnd, "constructors in/after an Optional Chain are not allowed");
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, "constructors in/after an Optional Chain are not allowed");
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }
  }, {
    key: 'parseNewArguments',
    value: function parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        var args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }
  }, {
    key: 'parseTemplateElement',
    value: function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.invalidTemplateEscapePosition || 0, "Invalid escape sequence in template");
        } else {
          this.state.invalidTemplateEscapePosition = null;
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }
  }, {
    key: 'parseTemplate',
    value: function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }
  }, {
    key: 'parseObj',
    value: function parseObj(isPattern, refShorthandDefaultPos) {
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(types.braceR)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            this.next();
            break;
          }
        }

        var prop = this.parseObjectMember(isPattern, refShorthandDefaultPos);
        if (!isPattern) this.checkDuplicatedProto(prop, propHash);

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      if (!this.match(types.eq) && propHash.start !== undefined) {
        this.raise(propHash.start, "Redefinition of __proto__ property");
      }

      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    }
  }, {
    key: 'isAsyncProp',
    value: function isAsyncProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();
    }
  }, {
    key: 'parseObjectMember',
    value: function parseObjectMember(isPattern, refShorthandDefaultPos) {
      var decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, "Stage 2 decorators disallow object literal property decorators");
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var startPos = void 0;
      var startLoc = void 0;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refShorthandDefaultPos) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      var containsEsc = this.state.containsEsc;
      this.parsePropertyName(prop);

      if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);
      return prop;
    }
  }, {
    key: 'isGetterOrSetterMethod',
    value: function isGetterOrSetterMethod(prop, isPattern) {
      return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
    }
  }, {
    key: 'getGetterSetterExpectedParamCount',
    value: function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
  }, {
    key: 'checkGetterSetterParams',
    value: function checkGetterSetterParams(method) {
      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var start = method.start;

      if (method.params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, "getter must not have any formal parameters");
        } else {
          this.raise(start, "setter must have exactly one formal parameter");
        }
      }

      if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
        this.raise(start, "setter function argument must not be a rest parameter");
      }
    }
  }, {
    key: 'parseObjectMethod',
    value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }

      if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
        if (isGenerator || isAsync) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        this.parseMethod(prop, false, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }
    }
  }, {
    key: 'parseObjectProperty',
    value: function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, true);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start) {
            refShorthandDefaultPos.start = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
  }, {
    key: 'parseObjPropValue',
    value: function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);
      if (!node) this.unexpected();
      return node;
    }
  }, {
    key: 'parsePropertyName',
    value: function parsePropertyName(prop) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();

        if (prop.key.type !== "PrivateName") {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }
  }, {
    key: 'initFunction',
    value: function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }
  }, {
    key: 'parseMethod',
    value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
      var inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.parseFunctionParams(node, allowModifiers);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBodyAndFinish(node, type, true);
      this.scope.exit();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }
  }, {
    key: 'parseArrowExpression',
    value: function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      if (params) this.setArrowFunctionParameters(node, params, trailingCommaPos);
      this.parseFunctionBody(node, true);
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
  }, {
    key: 'setArrowFunctionParameters',
    value: function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, true, "arrow function parameters", trailingCommaPos);
    }
  }, {
    key: 'isStrictBody',
    value: function isStrictBody(node) {
      var isBlockStatement = node.body.type === "BlockStatement";

      if (isBlockStatement && node.body.directives.length) {
        for (var _i2 = 0, _node$body$directives = node.body.directives; _i2 < _node$body$directives.length; _i2++) {
          var directive = _node$body$directives[_i2];

          if (directive.value.value === "use strict") {
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: 'parseFunctionBodyAndFinish',
    value: function parseFunctionBodyAndFinish(node, type) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }
  }, {
    key: 'parseFunctionBody',
    value: function parseFunctionBody(node, allowExpression) {
      var isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isExpression = allowExpression && !this.match(types.braceL);
      var oldStrict = this.state.strict;
      var useStrict = false;
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var nonSimple = !this.isSimpleParamList(node.params);

        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.state.end);

          if (useStrict && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
            this.raise(errorPos, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }

        var oldLabels = this.state.labels;
        this.state.labels = [];
        if (useStrict) this.state.strict = true;
        this.checkParams(node, !oldStrict && !useStrict && !allowExpression && !isMethod && !nonSimple, allowExpression, !oldStrict && useStrict);
        node.body = this.parseBlock(true, false);
        this.state.labels = oldLabels;
      }

      this.state.inParameters = oldInParameters;

      if (this.state.strict && node.id) {
        this.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, !oldStrict && useStrict);
      }

      this.state.strict = oldStrict;
    }
  }, {
    key: 'isSimpleParamList',
    value: function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    }
  }, {
    key: 'checkParams',
    value: function checkParams(node, allowDuplicates, isArrowFunction) {
      var strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var nameHash = Object.create(null);

      for (var i = 0; i < node.params.length; i++) {
        this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
      }
    }
  }, {
    key: 'parseExprList',
    value: function parseExprList(close, allowEmpty, refShorthandDefaultPos, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
      }

      return elts;
    }
  }, {
    key: 'parseExprListItem',
    value: function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, allowPlaceholder) {
      var elt = void 0;

      if (allowEmpty && this.match(types.comma)) {
        elt = null;
      } else if (this.match(types.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, "Unexpected argument placeholder");
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
      }

      return elt;
    }
  }, {
    key: 'parseIdentifier',
    value: function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
  }, {
    key: 'createIdentifier',
    value: function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
  }, {
    key: 'parseIdentifierName',
    value: function parseIdentifierName(pos, liberal) {
      var name = void 0;

      if (this.match(types.name)) {
        name = this.state.value;
      } else if (this.state.type.keyword) {
        name = this.state.type.keyword;

        if ((name === "class" || name === "function") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.input.charCodeAt(this.state.lastTokStart) !== 46)) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
      }

      this.next();
      return name;
    }
  }, {
    key: 'checkReservedWord',
    value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.scope.inGenerator && word === "yield") {
        this.raise(startLoc, "Can not use 'yield' as identifier inside a generator");
        return;
      }

      if (word === "await") {
        if (this.scope.inAsync) {
          this.raise(startLoc, "Can not use 'await' as identifier inside an async function");
          return;
        }

        if (this.state.awaitPos === -1 && (this.state.maybeInArrowParameters || this.isAwaitAllowed())) {
          this.state.awaitPos = this.state.start;
        }
      }

      if (this.state.inClassProperty && word === "arguments") {
        this.raise(startLoc, "'arguments' is not allowed in class field initializer");
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, 'Unexpected keyword \'' + word + '\'');
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        if (!this.scope.inAsync && word === "await") {
          this.raise(startLoc, "Can not use keyword 'await' outside an async function");
        } else {
          this.raise(startLoc, 'Unexpected reserved word \'' + word + '\'');
        }
      }
    }
  }, {
    key: 'isAwaitAllowed',
    value: function isAwaitAllowed() {
      if (this.scope.inFunction) return this.scope.inAsync;
      if (this.options.allowAwaitOutsideFunction) return true;
      if (this.hasPlugin("topLevelAwait")) return this.inModule;
      return false;
    }
  }, {
    key: 'parseAwait',
    value: function parseAwait() {
      var node = this.startNode();
      this.next();

      if (this.state.inParameters) {
        this.raise(node.start, "await is not allowed in async function parameters");
      } else if (this.state.awaitPos === -1) {
        this.state.awaitPos = node.start;
      }

      if (this.eat(types.star)) {
        this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary();
      }

      return this.finishNode(node, "AwaitExpression");
    }
  }, {
    key: 'parseYield',
    value: function parseYield(noIn) {
      var node = this.startNode();

      if (this.state.inParameters) {
        this.raise(node.start, "yield is not allowed in generator parameters");
      } else if (this.state.yieldPos === -1) {
        this.state.yieldPos = node.start;
      }

      this.next();

      if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }

      return this.finishNode(node, "YieldExpression");
    }
  }, {
    key: 'checkPipelineAtInfixOperator',
    value: function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, 'Pipeline head should not be a comma-separated sequence expression');
        }
      }
    }
  }, {
    key: 'parseSmartPipelineBody',
    value: function parseSmartPipelineBody(childExpression, startPos, startLoc) {
      var pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
      this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
    }
  }, {
    key: 'checkSmartPipelineBodyEarlyErrors',
    value: function checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized');
      } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
        this.raise(startPos, 'Pipeline body may not be a comma-separated sequence expression');
      }
    }
  }, {
    key: 'parseSmartPipelineBodyInStyle',
    value: function parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);

      switch (pipelineStyle) {
        case "PipelineBareFunction":
          bodyNode.callee = childExpression;
          break;

        case "PipelineBareConstructor":
          bodyNode.callee = childExpression.callee;
          break;

        case "PipelineBareAwaitedFunction":
          bodyNode.callee = childExpression.argument;
          break;

        case "PipelineTopicExpression":
          if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
            this.raise(startPos, 'Pipeline is in topic style but does not use topic reference');
          }

          bodyNode.expression = childExpression;
          break;

        default:
          throw new Error('Internal @babel/parser error: Unknown pipeline style (' + pipelineStyle + ')');
      }

      return this.finishNode(bodyNode, pipelineStyle);
    }
  }, {
    key: 'checkSmartPipelineBodyStyle',
    value: function checkSmartPipelineBodyStyle(expression) {
      switch (expression.type) {
        default:
          return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
      }
    }
  }, {
    key: 'isSimpleReference',
    value: function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }
  }, {
    key: 'withTopicPermittingContext',
    value: function withTopicPermittingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: 'withTopicForbiddingContext',
    value: function withTopicForbiddingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
  }, {
    key: 'withSoloAwaitPermittingContext',
    value: function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
  }, {
    key: 'registerTopicReference',
    value: function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
  }, {
    key: 'primaryTopicReferenceIsAllowedInCurrentTopicContext',
    value: function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
  }, {
    key: 'topicReferenceWasUsedInCurrentTopicContext',
    value: function topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
  }, {
    key: 'parseFSharpPipelineBody',
    value: function parseFSharpPipelineBody(prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
  }]);

  return ExpressionParser;
}(LValParser);

var loopLabel = {
  kind: "loop"
},
    switchLabel = {
  kind: "switch"
};
var FUNC_NO_FLAGS = 0,
    FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;

var StatementParser = function (_ExpressionParser) {
  _inherits(StatementParser, _ExpressionParser);

  function StatementParser() {
    _classCallCheck(this, StatementParser);

    return _possibleConstructorReturn(this, (StatementParser.__proto__ || Object.getPrototypeOf(StatementParser)).apply(this, arguments));
  }

  _createClass(StatementParser, [{
    key: 'parseTopLevel',
    value: function parseTopLevel(file, program) {
      program.sourceType = this.options.sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, types.eof);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i], 1),
              name = _Array$from$_i[0];

          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, 'Export \'' + name + '\' is not defined');
        }
      }

      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.state.tokens;
      return this.finishNode(file, "File");
    }
  }, {
    key: 'stmtToDirective',
    value: function stmtToDirective(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    }
  }, {
    key: 'parseInterpreterDirective',
    value: function parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
  }, {
    key: 'isLet',
    value: function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      var next = this.nextTokenStart();
      var nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        var pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    }
  }, {
    key: 'parseStatement',
    value: function parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }
  }, {
    key: 'parseStatementContent',
    value: function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind = void 0;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, "In strict mode code, functions can only be declared at top level or inside a block");
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, "In non-strict mode code, functions can only be declared at top level, " + "inside a block, or as the body of an if statement");
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, "Lexical declaration cannot appear in a single-statement context");
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._export:
        case types._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }

            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
            }

            this.next();
            var result = void 0;

            if (starttype === types._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, "Async functions can only be declared at the top level or inside a block");
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }
  }, {
    key: 'assertModuleNodeAllowed',
    value: function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, '\'import\' and \'export\' may appear only with \'sourceType: "module"\'', {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        });
      }
    }
  }, {
    key: 'takeDecorators',
    value: function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }
  }, {
    key: 'canHaveLeadingDecorator',
    value: function canHaveLeadingDecorator() {
      return this.match(types._class);
    }
  }, {
    key: 'parseDecorators',
    value: function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, "Using the export keyword between a decorator and a class is not allowed. " + "Please use `export @dec class` instead.");
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
      }
    }
  }, {
    key: 'parseDecorator',
    value: function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr = void 0;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            var _node16 = this.startNodeAt(startPos, startLoc);
            _node16.object = expr;
            _node16.property = this.parseIdentifier(true);
            _node16.computed = false;
            expr = this.finishNode(_node16, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }
  }, {
    key: 'parseMaybeDecoratorArguments',
    value: function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }
  }, {
    key: 'parseBreakContinueStatement',
    value: function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
  }, {
    key: 'verifyBreakContinue',
    value: function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i = void 0;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
    }
  }, {
    key: 'parseDebuggerStatement',
    value: function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
  }, {
    key: 'parseHeaderExpression',
    value: function parseHeaderExpression() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    }
  }, {
    key: 'parseDoStatement',
    value: function parseDoStatement(node) {
      var _this50 = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this50.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    }
  }, {
    key: 'parseForStatement',
    value: function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var isLet = this.isLet();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        var _init = this.startNode();
        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var refShorthandDefaultPos = {
        start: 0
      };
      var init = this.parseExpression(true, refShorthandDefaultPos);

      if (this.match(types._in) || this.isContextual("of")) {
        var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.toAssignable(init, undefined, description);
        this.checkLVal(init, undefined, undefined, description);
        return this.parseForIn(node, init, awaitAt);
      } else if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }
  }, {
    key: 'parseFunctionStatement',
    value: function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }
  }, {
    key: 'parseIfStatement',
    value: function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }
  }, {
    key: 'parseReturnStatement',
    value: function parseReturnStatement(node) {
      if (!this.scope.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, "'return' outside of function");
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }
  }, {
    key: 'parseSwitchStatement',
    value: function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur = void 0;

      for (var sawDefault; !this.match(types.braceR);) {
        if (this.match(types._case) || this.match(types._default)) {
          var isCase = this.match(types._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, "Multiple default clauses");
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
  }, {
    key: 'parseThrowStatement',
    value: function parseThrowStatement(node) {
      this.next();

      if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
        this.raise(this.state.lastTokEnd, "Illegal newline after throw");
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
  }, {
    key: 'parseTryStatement',
    value: function parseTryStatement(node) {
      var _this51 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, BIND_LEXICAL, null, "catch clause");
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(function () {
          return _this51.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }

      return this.finishNode(node, "TryStatement");
    }
  }, {
    key: 'parseVarStatement',
    value: function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
  }, {
    key: 'parseWhileStatement',
    value: function parseWhileStatement(node) {
      var _this52 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this52.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
  }, {
    key: 'parseWithStatement',
    value: function parseWithStatement(node) {
      var _this53 = this;

      if (this.state.strict) {
        this.raise(this.state.start, "'with' in strict mode");
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(function () {
        return _this53.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    }
  }, {
    key: 'parseEmptyStatement',
    value: function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
  }, {
    key: 'parseLabeledStatement',
    value: function parseLabeledStatement(node, maybeName, expr, context) {
      for (var _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {
        var label = _this$state$labels[_i2];

        if (label.name === maybeName) {
          this.raise(expr.start, 'Label \'' + maybeName + '\' is already declared');
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];

        if (_label.statementStart === node.start) {
          _label.statementStart = this.state.start;
          _label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
  }, {
    key: 'parseExpressionStatement',
    value: function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
  }, {
    key: 'parseBlock',
    value: function parseBlock() {
      var allowDirectives = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var createNewLexicalScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var node = this.startNode();
      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types.braceR);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }
  }, {
    key: 'isValidDirective',
    value: function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
  }, {
    key: 'parseBlockBody',
    value: function parseBlockBody(node, allowDirectives, topLevel, end) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);
    }
  }, {
    key: 'parseBlockOrModuleBlockBody',
    value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end) {
      var parsedNonDirective = false;
      var oldStrict = void 0;
      var octalPosition = void 0;

      while (!this.eat(end)) {
        if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
          octalPosition = this.state.octalPosition;
        }

        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
          var directive = this.stmtToDirective(stmt);
          directives.push(directive);

          if (oldStrict === undefined && directive.value.value === "use strict") {
            oldStrict = this.state.strict;
            this.setStrict(true);

            if (octalPosition) {
              this.raise(octalPosition, "Octal literal in strict mode");
            }
          }

          continue;
        }

        parsedNonDirective = true;
        body.push(stmt);
      }

      if (oldStrict === false) {
        this.setStrict(false);
      }
    }
  }, {
    key: 'parseFor',
    value: function parseFor(node, init) {
      var _this54 = this;

      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this54.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
  }, {
    key: 'parseForIn',
    value: function parseForIn(node, init, awaitAt) {
      var _this55 = this;

      var isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, (isForIn ? "for-in" : "for-of") + ' loop variable declaration may not have an initializer');
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this55.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
  }, {
    key: 'parseVar',
    value: function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else {
          if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.unexpected();
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
      }

      return node;
    }
  }, {
    key: 'parseVarId',
    value: function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
    }
  }, {
    key: 'parseFunction',
    value: function parseFunction(node) {
      var _this56 = this;

      var statement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FUNC_NO_FLAGS;
      var isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(this.state.start, "Generators can only be declared at the top level or inside a block");
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInClassProperty = this.state.inClassProperty;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.inClassProperty = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.scope.enter(functionFlags(node.async, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node);
      this.withTopicForbiddingContext(function () {
        _this56.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inClassProperty = oldInClassProperty;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }
  }, {
    key: 'parseFunctionId',
    value: function parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    }
  }, {
    key: 'parseFunctionParams',
    value: function parseFunctionParams(node, allowModifiers) {
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = true;
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
      this.state.inParameters = oldInParameters;
      this.checkYieldAwaitInDefaultParams();
    }
  }, {
    key: 'registerFunctionStatementId',
    value: function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }
  }, {
    key: 'parseClass',
    value: function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass);
      this.state.strict = oldStrict;
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
  }, {
    key: 'isClassProperty',
    value: function isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    }
  }, {
    key: 'isClassMethod',
    value: function isClassMethod() {
      return this.match(types.parenL);
    }
  }, {
    key: 'isNonstaticConstructor',
    value: function isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
  }, {
    key: 'parseClassBody',
    value: function parseClassBody(constructorAllowsSuper) {
      var _this57 = this;

      this.state.classLevel++;
      var state = {
        hadConstructor: false
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(function () {
        while (!_this57.eat(types.braceR)) {
          if (_this57.eat(types.semi)) {
            if (decorators.length > 0) {
              throw _this57.raise(_this57.state.lastTokEnd, "Decorators must not be followed by a semicolon");
            }

            continue;
          }

          if (_this57.match(types.at)) {
            decorators.push(_this57.parseDecorator());
            continue;
          }

          var member = _this57.startNode();

          if (decorators.length) {
            member.decorators = decorators;
            _this57.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }

          _this57.parseClassMember(classBody, member, state, constructorAllowsSuper);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this57.raise(member.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?");
          }
        }
      });

      if (decorators.length) {
        throw this.raise(this.state.start, "You have trailing decorators with no method");
      }

      this.state.classLevel--;
      return this.finishNode(classBody, "ClassBody");
    }
  }, {
    key: 'parseClassMember',
    value: function parseClassMember(classBody, member, state, constructorAllowsSuper) {
      var isStatic = false;
      var containsEsc = this.state.containsEsc;

      if (this.match(types.name) && this.state.value === "static") {
        var key = this.parseIdentifier(true);

        if (this.isClassMethod()) {
          var method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return;
        } else if (this.isClassProperty()) {
          var prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return;
        } else if (containsEsc) {
          throw this.unexpected();
        }

        isStatic = true;
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    }
  }, {
    key: 'parseClassMemberWithIsStatic',
    value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member.static = isStatic;

      if (this.eat(types.star)) {
        method.kind = "method";
        this.parseClassPropertyName(method);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, "Constructor can't be a generator");
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parseClassPropertyName(member);
      var isPrivate = key.type === "PrivateName";
      var isSimple = key.type === "Identifier";
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, "Duplicate constructor in the same class");
          }

          state.hadConstructor = true;
          allowsDirectSuper = constructorAllowsSuper;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        var isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        this.parseClassPropertyName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, "Constructor can't be an async function");
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
        method.kind = key.name;
        this.parseClassPropertyName(publicMethod);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, "Constructor can't have get/set modifier");
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
  }, {
    key: 'parseClassPropertyName',
    value: function parseClassPropertyName(member) {
      var key = this.parsePropertyName(member);

      if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
        this.raise(key.start, "Classes may not have static property named prototype");
      }

      if (key.type === "PrivateName" && key.id.name === "constructor") {
        this.raise(key.start, "Classes may not have a private field named '#constructor'");
      }

      return key;
    }
  }, {
    key: 'pushClassProperty',
    value: function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, "Classes may not have a field named 'constructor'");
      }

      classBody.body.push(this.parseClassProperty(prop));
    }
  }, {
    key: 'pushClassPrivateProperty',
    value: function pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      classBody.body.push(this.parseClassPrivateProperty(prop));
    }
  }, {
    key: 'pushClassMethod',
    value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
  }, {
    key: 'pushClassPrivateMethod',
    value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true));
    }
  }, {
    key: 'parsePostMemberNameModifiers',
    value: function parsePostMemberNameModifiers(methodOrProp) {}
  }, {
    key: 'parseAccessModifier',
    value: function parseAccessModifier() {
      return undefined;
    }
  }, {
    key: 'parseClassPrivateProperty',
    value: function parseClassPrivateProperty(node) {
      this.state.inClassProperty = true;
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
      this.semicolon();
      this.state.inClassProperty = false;
      this.scope.exit();
      return this.finishNode(node, "ClassPrivateProperty");
    }
  }, {
    key: 'parseClassProperty',
    value: function parseClassProperty(node) {
      if (!node.typeAnnotation) {
        this.expectPlugin("classProperties");
      }

      this.state.inClassProperty = true;
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);

      if (this.match(types.eq)) {
        this.expectPlugin("classProperties");
        this.next();
        node.value = this.parseMaybeAssign();
      } else {
        node.value = null;
      }

      this.semicolon();
      this.state.inClassProperty = false;
      this.scope.exit();
      return this.finishNode(node, "ClassProperty");
    }
  }, {
    key: 'parseClassId',
    value: function parseClassId(node, isStatement, optionalId) {
      var bindingType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BIND_CLASS;

      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, bindingType, undefined, "class name");
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, "A class name is required");
        }
      }
    }
  }, {
    key: 'parseClassSuper',
    value: function parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    }
  }, {
    key: 'parseExport',
    value: function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types.braceL);
      }

      var hasDeclaration = void 0;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types.braceL);
    }
  }, {
    key: 'eatExportStar',
    value: function eatExportStar(node) {
      return this.eat(types.star);
    }
  }, {
    key: 'maybeParseExportDefaultSpecifier',
    value: function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }
  }, {
    key: 'maybeParseExportNamespaceSpecifier',
    value: function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }
  }, {
    key: 'maybeParseExportNamedSpecifiers',
    value: function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        var _node$specifiers2;

        if (!node.specifiers) node.specifiers = [];
        (_node$specifiers2 = node.specifiers).push.apply(_node$specifiers2, _toConsumableArray(this.parseExportSpecifiers()));
        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }
  }, {
    key: 'maybeParseExportDeclaration',
    value: function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        if (this.isContextual("async")) {
          var next = this.nextTokenStart();

          if (!this.isUnparsedContextual(next, "function")) {
            this.unexpected(next, 'Unexpected token, expected "function"');
          }
        }

        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }
  }, {
    key: 'isAsyncFunction',
    value: function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
  }, {
    key: 'parseExportDefaultExpression',
    value: function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
        throw this.raise(this.state.start, "Only expressions, functions or classes are allowed as the `default` export.");
      } else {
        var res = this.parseMaybeAssign();
        this.semicolon();
        return res;
      }
    }
  }, {
    key: 'parseExportDeclaration',
    value: function parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
  }, {
    key: 'isExportDefaultSpecifier',
    value: function isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        return this.state.value !== "async" && this.state.value !== "let";
      }

      if (!this.match(types._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, "from");
    }
  }, {
    key: 'parseExportFrom',
    value: function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }
  }, {
    key: 'shouldParseExportDeclaration',
    value: function shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
  }, {
    key: 'checkExport',
    value: function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
        } else if (node.specifiers && node.specifiers.length) {
          for (var _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {
            var specifier = _node$specifiers[_i3];
            this.checkDuplicateExports(specifier, specifier.exported.name);

            if (!isFrom && specifier.local) {
              this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
              this.scope.checkLocalExport(specifier.local);
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {
              var declaration = _node$declaration$dec[_i4];
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

        if (!node.declaration || !isClass) {
          throw this.raise(node.start, "You can only use decorators on an export when exporting a class");
        }

        this.takeDecorators(node.declaration);
      }
    }
  }, {
    key: 'checkDeclaration',
    value: function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {
          var prop = _node$properties[_i5];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {
          var elem = _node$elements[_i6];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
  }, {
    key: 'checkDuplicateExports',
    value: function checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(node.start, name === "default" ? "Only one default export allowed per module." : '`' + name + '` has already been exported. Exported identifiers must be unique.');
      }

      this.state.exportedIdentifiers.push(name);
    }
  }, {
    key: 'parseExportSpecifiers',
    value: function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        var node = this.startNode();
        node.local = this.parseIdentifier(true);
        node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    }
  }, {
    key: 'parseImport',
    value: function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
  }, {
    key: 'parseImportSource',
    value: function parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    }
  }, {
    key: 'shouldParseDefaultImport',
    value: function shouldParseDefaultImport(node) {
      return this.match(types.name);
    }
  }, {
    key: 'parseImportSpecifierLocal',
    value: function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    }
  }, {
    key: 'maybeParseDefaultImportSpecifier',
    value: function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    }
  }, {
    key: 'maybeParseStarImportSpecifier',
    value: function maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    }
  }, {
    key: 'parseNamedImportSpecifiers',
    value: function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(this.state.start, "ES2015 named imports do not destructure. " + "Use another statement for destructuring after the import.");
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }
  }, {
    key: 'parseImportSpecifier',
    value: function parseImportSpecifier(node) {
      var specifier = this.startNode();
      specifier.imported = this.parseIdentifier(true);

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
        specifier.local = specifier.imported.__clone();
      }

      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
  }]);

  return StatementParser;
}(ExpressionParser);

var Parser = function (_StatementParser) {
  _inherits(Parser, _StatementParser);

  function Parser(options, input) {
    _classCallCheck(this, Parser);

    options = getOptions(options);

    var _this58 = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this, options, input));

    var ScopeHandler = _this58.getScopeHandler();
    _this58.options = options;
    _this58.inModule = _this58.options.sourceType === "module";
    _this58.scope = new ScopeHandler(_this58.raise.bind(_this58), _this58.inModule);
    _this58.plugins = pluginsMap(_this58.options.plugins);
    _this58.filename = options.sourceFilename;
    return _this58;
  }

  _createClass(Parser, [{
    key: 'getScopeHandler',
    value: function getScopeHandler() {
      return ScopeHandler;
    }
  }, {
    key: 'parse',
    value: function parse() {
      this.scope.enter(SCOPE_PROGRAM);
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }]);

  return Parser;
}(StatementParser);

function pluginsMap(plugins) {
  var pluginMap = new Map();

  for (var _i = 0; _i < plugins.length; _i++) {
    var plugin = plugins[_i];

    var _ref17 = Array.isArray(plugin) ? plugin : [plugin, {}],
        _ref18 = _slicedToArray(_ref17, 2),
        name = _ref18[0],
        options = _ref18[1];

    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
  }

  return pluginMap;
}

function parse(input, options) {
  if (options && options.sourceType === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      var parser = getParser(options, input);
      var ast = parser.parse();

      if (parser.sawUnambiguousESM) {
        return ast;
      }

      if (parser.ambiguousScriptDifferentAst) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused) {}
      } else {
        ast.program.sourceType = "script";
      }

      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (_unused2) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}
function parseExpression(input, options) {
  var parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}

function getParser(options, input) {
  var cls = Parser;

  if (options && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

var parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  var pluginList = mixinPluginNames.filter(function (name) {
    return hasPlugin(pluginsFromOptions, name);
  });
  var key = pluginList.join("/");
  var cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;

    for (var _i = 0; _i < pluginList.length; _i++) {
      var plugin = pluginList[_i];
      cls = mixinPlugins[plugin](cls);
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;