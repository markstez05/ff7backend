'use strict';

var stringWidth = require('string-width');
var chalk = require('chalk');
var widestLine = require('widest-line');
var cliBoxes = require('cli-boxes');
var camelCase = require('camelcase');
var ansiAlign = require('ansi-align');
var termSize = require('term-size');

var getObject = function getObject(detail) {
	var obj = void 0;

	if (typeof detail === 'number') {
		obj = {
			top: detail,
			right: detail * 3,
			bottom: detail,
			left: detail * 3
		};
	} else {
		obj = Object.assign({
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		}, detail);
	}

	return obj;
};

var getBorderChars = function getBorderChars(borderStyle) {
	var sides = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft', 'vertical', 'horizontal'];

	var chars = void 0;

	if (typeof borderStyle === 'string') {
		chars = cliBoxes[borderStyle];

		if (!chars) {
			throw new TypeError('Invalid border style: ' + borderStyle);
		}
	} else {
		sides.forEach(function (key) {
			if (!borderStyle[key] || typeof borderStyle[key] !== 'string') {
				throw new TypeError('Invalid border style: ' + key);
			}
		});

		chars = borderStyle;
	}

	return chars;
};

var getBackgroundColorName = function getBackgroundColorName(x) {
	return camelCase('bg', x);
};

module.exports = function (text, opts) {
	opts = Object.assign({
		padding: 0,
		borderStyle: 'single',
		dimBorder: false,
		align: 'left',
		float: 'left'
	}, opts);

	if (opts.backgroundColor) {
		opts.backgroundColor = getBackgroundColorName(opts.backgroundColor);
	}

	if (opts.borderColor && !chalk[opts.borderColor]) {
		throw new Error(opts.borderColor + ' is not a valid borderColor');
	}

	if (opts.backgroundColor && !chalk[opts.backgroundColor]) {
		throw new Error(opts.backgroundColor + ' is not a valid backgroundColor');
	}

	var chars = getBorderChars(opts.borderStyle);
	var padding = getObject(opts.padding);
	var margin = getObject(opts.margin);

	var colorizeBorder = function colorizeBorder(x) {
		var ret = opts.borderColor ? chalk[opts.borderColor](x) : x;
		return opts.dimBorder ? chalk.dim(ret) : ret;
	};

	var colorizeContent = function colorizeContent(x) {
		return opts.backgroundColor ? chalk[opts.backgroundColor](x) : x;
	};

	text = ansiAlign(text, { align: opts.align });

	var NL = '\n';
	var PAD = ' ';

	var lines = text.split(NL);

	if (padding.top > 0) {
		lines = Array(padding.top).fill('').concat(lines);
	}

	if (padding.bottom > 0) {
		lines = lines.concat(Array(padding.bottom).fill(''));
	}

	var contentWidth = widestLine(text) + padding.left + padding.right;
	var paddingLeft = PAD.repeat(padding.left);
	var columns = termSize().columns;
	var marginLeft = PAD.repeat(margin.left);

	if (opts.float === 'center') {
		var padWidth = Math.max((columns - contentWidth) / 2, 0);
		marginLeft = PAD.repeat(padWidth);
	} else if (opts.float === 'right') {
		var _padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);
		marginLeft = PAD.repeat(_padWidth);
	}

	var horizontal = chars.horizontal.repeat(contentWidth);
	var top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight);
	var bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));
	var side = colorizeBorder(chars.vertical);

	var middle = lines.map(function (line) {
		var paddingRight = PAD.repeat(contentWidth - stringWidth(line) - padding.left);
		return marginLeft + side + colorizeContent(paddingLeft + line + paddingRight) + side;
	}).join(NL);

	return top + NL + middle + NL + bottom;
};

module.exports._borderStyles = cliBoxes;