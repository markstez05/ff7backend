'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MiniPass = require('minipass');
var EE = require('events').EventEmitter;
var fs = require('fs');

// for writev
var binding = process.binding('fs');
var writeBuffers = binding.writeBuffers;
var FSReqWrap = binding.FSReqWrap;

var _autoClose = Symbol('_autoClose');
var _close = Symbol('_close');
var _ended = Symbol('_ended');
var _fd = Symbol('_fd');
var _finished = Symbol('_finished');
var _flags = Symbol('_flags');
var _flush = Symbol('_flush');
var _handleChunk = Symbol('_handleChunk');
var _makeBuf = Symbol('_makeBuf');
var _mode = Symbol('_mode');
var _needDrain = Symbol('_needDrain');
var _onerror = Symbol('_onerror');
var _onopen = Symbol('_onopen');
var _onread = Symbol('_onread');
var _onwrite = Symbol('_onwrite');
var _open = Symbol('_open');
var _path = Symbol('_path');
var _pos = Symbol('_pos');
var _queue = Symbol('_queue');
var _read = Symbol('_read');
var _readSize = Symbol('_readSize');
var _reading = Symbol('_reading');
var _remain = Symbol('_remain');
var _size = Symbol('_size');
var _write = Symbol('_write');
var _writing = Symbol('_writing');
var _defaultFlag = Symbol('_defaultFlag');

var ReadStream = function (_MiniPass) {
  _inherits(ReadStream, _MiniPass);

  function ReadStream(path, opt) {
    _classCallCheck(this, ReadStream);

    opt = opt || {};

    var _this = _possibleConstructorReturn(this, (ReadStream.__proto__ || Object.getPrototypeOf(ReadStream)).call(this, opt));

    _this.writable = false;

    if (typeof path !== 'string') throw new TypeError('path must be a string');

    _this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
    _this[_path] = path;
    _this[_readSize] = opt.readSize || 16 * 1024 * 1024;
    _this[_reading] = false;
    _this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;
    _this[_remain] = _this[_size];
    _this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;

    if (typeof _this[_fd] === 'number') _this[_read]();else _this[_open]();
    return _this;
  }

  _createClass(ReadStream, [{
    key: 'write',
    value: function write() {
      throw new TypeError('this is a readable stream');
    }
  }, {
    key: 'end',
    value: function end() {
      throw new TypeError('this is a readable stream');
    }
  }, {
    key: _open,
    value: function value() {
      var _this2 = this;

      fs.open(this[_path], 'r', function (er, fd) {
        return _this2[_onopen](er, fd);
      });
    }
  }, {
    key: _onopen,
    value: function value(er, fd) {
      if (er) this[_onerror](er);else {
        this[_fd] = fd;
        this.emit('open', fd);
        this[_read]();
      }
    }
  }, {
    key: _makeBuf,
    value: function value() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
  }, {
    key: _read,
    value: function value() {
      var _this3 = this;

      if (!this[_reading]) {
        this[_reading] = true;
        var buf = this[_makeBuf]();
        /* istanbul ignore if */
        if (buf.length === 0) return process.nextTick(function () {
          return _this3[_onread](null, 0, buf);
        });
        fs.read(this[_fd], buf, 0, buf.length, null, function (er, br, buf) {
          return _this3[_onread](er, br, buf);
        });
      }
    }
  }, {
    key: _onread,
    value: function value(er, br, buf) {
      this[_reading] = false;
      if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();
    }
  }, {
    key: _close,
    value: function value() {
      var _this4 = this;

      if (this[_autoClose] && typeof this[_fd] === 'number') {
        fs.close(this[_fd], function (_) {
          return _this4.emit('close');
        });
        this[_fd] = null;
      }
    }
  }, {
    key: _onerror,
    value: function value(er) {
      this[_reading] = true;
      this[_close]();
      this.emit('error', er);
    }
  }, {
    key: _handleChunk,
    value: function value(br, buf) {
      var ret = false;
      // no effect if infinite
      this[_remain] -= br;
      if (br > 0) ret = _get(ReadStream.prototype.__proto__ || Object.getPrototypeOf(ReadStream.prototype), 'write', this).call(this, br < buf.length ? buf.slice(0, br) : buf);

      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        _get(ReadStream.prototype.__proto__ || Object.getPrototypeOf(ReadStream.prototype), 'end', this).call(this);
      }

      return ret;
    }
  }, {
    key: 'emit',
    value: function emit(ev, data) {
      switch (ev) {
        case 'prefinish':
        case 'finish':
          break;

        case 'drain':
          if (typeof this[_fd] === 'number') this[_read]();
          break;

        default:
          return _get(ReadStream.prototype.__proto__ || Object.getPrototypeOf(ReadStream.prototype), 'emit', this).call(this, ev, data);
      }
    }
  }, {
    key: 'fd',
    get: function get() {
      return this[_fd];
    }
  }, {
    key: 'path',
    get: function get() {
      return this[_path];
    }
  }]);

  return ReadStream;
}(MiniPass);

var ReadStreamSync = function (_ReadStream) {
  _inherits(ReadStreamSync, _ReadStream);

  function ReadStreamSync() {
    _classCallCheck(this, ReadStreamSync);

    return _possibleConstructorReturn(this, (ReadStreamSync.__proto__ || Object.getPrototypeOf(ReadStreamSync)).apply(this, arguments));
  }

  _createClass(ReadStreamSync, [{
    key: _open,
    value: function value() {
      var threw = true;
      try {
        this[_onopen](null, fs.openSync(this[_path], 'r'));
        threw = false;
      } finally {
        if (threw) this[_close]();
      }
    }
  }, {
    key: _read,
    value: function value() {
      var threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            var buf = this[_makeBuf]();
            /* istanbul ignore next */
            var br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf)) break;
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw) this[_close]();
      }
    }
  }, {
    key: _close,
    value: function value() {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        try {
          fs.closeSync(this[_fd]);
        } catch (er) {}
        this[_fd] = null;
        this.emit('close');
      }
    }
  }]);

  return ReadStreamSync;
}(ReadStream);

var WriteStream = function (_EE) {
  _inherits(WriteStream, _EE);

  function WriteStream(path, opt) {
    _classCallCheck(this, WriteStream);

    opt = opt || {};

    var _this6 = _possibleConstructorReturn(this, (WriteStream.__proto__ || Object.getPrototypeOf(WriteStream)).call(this, opt));

    _this6.readable = false;
    _this6[_writing] = false;
    _this6[_ended] = false;
    _this6[_needDrain] = false;
    _this6[_queue] = [];
    _this6[_path] = path;
    _this6[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
    _this6[_mode] = opt.mode === undefined ? 438 : opt.mode;
    _this6[_pos] = typeof opt.start === 'number' ? opt.start : null;
    _this6[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;

    // truncating makes no sense when writing into the middle
    var defaultFlag = _this6[_pos] !== null ? 'r+' : 'w';
    _this6[_defaultFlag] = opt.flags === undefined;
    _this6[_flags] = _this6[_defaultFlag] ? defaultFlag : opt.flags;

    if (_this6[_fd] === null) _this6[_open]();
    return _this6;
  }

  _createClass(WriteStream, [{
    key: _onerror,
    value: function value(er) {
      this[_close]();
      this[_writing] = true;
      this.emit('error', er);
    }
  }, {
    key: _open,
    value: function value() {
      var _this7 = this;

      fs.open(this[_path], this[_flags], this[_mode], function (er, fd) {
        return _this7[_onopen](er, fd);
      });
    }
  }, {
    key: _onopen,
    value: function value(er, fd) {
      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {
        this[_flags] = 'w';
        this[_open]();
      } else if (er) this[_onerror](er);else {
        this[_fd] = fd;
        this.emit('open', fd);
        this[_flush]();
      }
    }
  }, {
    key: 'end',
    value: function end(buf, enc) {
      if (buf) this.write(buf, enc);

      this[_ended] = true;

      // synthetic after-write logic, where drain/finish live
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);
    }
  }, {
    key: 'write',
    value: function write(buf, enc) {
      if (typeof buf === 'string') buf = new Buffer(buf, enc);

      if (this[_ended]) {
        this.emit('error', new Error('write() after end()'));
        return false;
      }

      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }

      this[_writing] = true;
      this[_write](buf);
      return true;
    }
  }, {
    key: _write,
    value: function value(buf) {
      var _this8 = this;

      fs.write(this[_fd], buf, 0, buf.length, this[_pos], function (er, bw) {
        return _this8[_onwrite](er, bw);
      });
    }
  }, {
    key: _onwrite,
    value: function value(er, bw) {
      if (er) this[_onerror](er);else {
        if (this[_pos] !== null) this[_pos] += bw;
        if (this[_queue].length) this[_flush]();else {
          this[_writing] = false;

          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit('finish');
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit('drain');
          }
        }
      }
    }
  }, {
    key: _flush,
    value: function value() {
      var _this9 = this;

      if (this[_queue].length === 0) {
        if (this[_ended]) this[_onwrite](null, 0);
      } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {
        var iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], function (er, bw) {
          return _this9[_onwrite](er, bw);
        });
      }
    }
  }, {
    key: _close,
    value: function value() {
      var _this10 = this;

      if (this[_autoClose] && typeof this[_fd] === 'number') {
        fs.close(this[_fd], function (_) {
          return _this10.emit('close');
        });
        this[_fd] = null;
      }
    }
  }, {
    key: 'fd',
    get: function get() {
      return this[_fd];
    }
  }, {
    key: 'path',
    get: function get() {
      return this[_path];
    }
  }]);

  return WriteStream;
}(EE);

var WriteStreamSync = function (_WriteStream) {
  _inherits(WriteStreamSync, _WriteStream);

  function WriteStreamSync() {
    _classCallCheck(this, WriteStreamSync);

    return _possibleConstructorReturn(this, (WriteStreamSync.__proto__ || Object.getPrototypeOf(WriteStreamSync)).apply(this, arguments));
  }

  _createClass(WriteStreamSync, [{
    key: _open,
    value: function value() {
      var fd = void 0;
      try {
        fd = fs.openSync(this[_path], this[_flags], this[_mode]);
      } catch (er) {
        if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {
          this[_flags] = 'w';
          return this[_open]();
        } else throw er;
      }
      this[_onopen](null, fd);
    }
  }, {
    key: _close,
    value: function value() {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        try {
          fs.closeSync(this[_fd]);
        } catch (er) {}
        this[_fd] = null;
        this.emit('close');
      }
    }
  }, {
    key: _write,
    value: function value(buf) {
      try {
        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
      } catch (er) {
        this[_onwrite](er, 0);
      }
    }
  }]);

  return WriteStreamSync;
}(WriteStream);

var writev = function writev(fd, iovec, pos, cb) {
  var done = function done(er, bw) {
    return cb(er, bw, iovec);
  };
  var req = new FSReqWrap();
  req.oncomplete = done;
  binding.writeBuffers(fd, iovec, pos, req);
};

exports.ReadStream = ReadStream;
exports.ReadStreamSync = ReadStreamSync;

exports.WriteStream = WriteStream;
exports.WriteStreamSync = WriteStreamSync;