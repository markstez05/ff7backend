'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EE = require('events');
var Yallist = require('yallist');
var EOF = Symbol('EOF');
var MAYBE_EMIT_END = Symbol('maybeEmitEnd');
var EMITTED_END = Symbol('emittedEnd');
var CLOSED = Symbol('closed');
var READ = Symbol('read');
var FLUSH = Symbol('flush');
var doIter = process.env._MP_NO_ITERATOR_SYMBOLS_ !== '1';
var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
var ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');
var FLUSHCHUNK = Symbol('flushChunk');
var SD = require('string_decoder').StringDecoder;
var ENCODING = Symbol('encoding');
var DECODER = Symbol('decoder');
var FLOWING = Symbol('flowing');
var RESUME = Symbol('resume');
var BUFFERLENGTH = Symbol('bufferLength');
var BUFFERPUSH = Symbol('bufferPush');
var BUFFERSHIFT = Symbol('bufferShift');
var OBJECTMODE = Symbol('objectMode');

// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from
// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.
// .M, this is fine .\^/M..
var B = Buffer;
/* istanbul ignore next */
if (!B.alloc) {
  B = require('safe-buffer').Buffer;
}

module.exports = function (_EE) {
  _inherits(MiniPass, _EE);

  function MiniPass(options) {
    _classCallCheck(this, MiniPass);

    var _this = _possibleConstructorReturn(this, (MiniPass.__proto__ || Object.getPrototypeOf(MiniPass)).call(this));

    _this[FLOWING] = false;
    _this.pipes = new Yallist();
    _this.buffer = new Yallist();
    _this[OBJECTMODE] = options && options.objectMode || false;
    if (_this[OBJECTMODE]) _this[ENCODING] = null;else _this[ENCODING] = options && options.encoding || null;
    if (_this[ENCODING] === 'buffer') _this[ENCODING] = null;
    _this[DECODER] = _this[ENCODING] ? new SD(_this[ENCODING]) : null;
    _this[EOF] = false;
    _this[EMITTED_END] = false;
    _this[CLOSED] = false;
    _this.writable = true;
    _this.readable = true;
    _this[BUFFERLENGTH] = 0;
    return _this;
  }

  _createClass(MiniPass, [{
    key: 'setEncoding',
    value: function setEncoding(enc) {
      this.encoding = enc;
    }
  }, {
    key: 'write',
    value: function write(chunk, encoding, cb) {
      if (this[EOF]) throw new Error('write after end');

      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';

      if (!encoding) encoding = 'utf8';

      // fast-path writing strings of same encoding to a stream with
      // an empty buffer, skipping the buffer/decoder dance
      if (typeof chunk === 'string' && !this[OBJECTMODE] &&
      // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = B.from(chunk, encoding);
      }

      if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);

      try {
        return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);
      } finally {
        this.emit('readable');
        if (cb) cb();
      }
    }
  }, {
    key: 'read',
    value: function read(n) {
      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;

        if (this[OBJECTMODE]) n = null;

        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);
        }

        return this[READ](n || null, this.buffer.head.value);
      } finally {
        this[MAYBE_EMIT_END]();
      }
    }
  }, {
    key: READ,
    value: function value(n, chunk) {
      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {
        this.buffer.head.value = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }

      this.emit('data', chunk);

      if (!this.buffer.length && !this[EOF]) this.emit('drain');

      return chunk;
    }
  }, {
    key: 'end',
    value: function end(chunk, encoding, cb) {
      if (typeof chunk === 'function') cb = chunk, chunk = null;
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (chunk) this.write(chunk, encoding);
      if (cb) this.once('end', cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing) this[MAYBE_EMIT_END]();
    }

    // don't let the internal resume be overwritten

  }, {
    key: RESUME,
    value: function value() {
      this[FLOWING] = true;
      this.emit('resume');
      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');
    }
  }, {
    key: 'resume',
    value: function resume() {
      return this[RESUME]();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this[FLOWING] = false;
    }
  }, {
    key: BUFFERPUSH,
    value: function value(chunk) {
      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;
      return this.buffer.push(chunk);
    }
  }, {
    key: BUFFERSHIFT,
    value: function value() {
      if (this.buffer.length) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;
      }
      return this.buffer.shift();
    }
  }, {
    key: FLUSH,
    value: function value() {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));

      if (!this.buffer.length && !this[EOF]) this.emit('drain');
    }
  }, {
    key: FLUSHCHUNK,
    value: function value(chunk) {
      return chunk ? (this.emit('data', chunk), this.flowing) : false;
    }
  }, {
    key: 'pipe',
    value: function pipe(dest, opts) {
      var _this2 = this;

      if (dest === process.stdout || dest === process.stderr) (opts = opts || {}).end = false;
      var p = { dest: dest, opts: opts, ondrain: function ondrain(_) {
          return _this2[RESUME]();
        } };
      this.pipes.push(p);

      dest.on('drain', p.ondrain);
      this[RESUME]();
      return dest;
    }
  }, {
    key: 'addListener',
    value: function addListener(ev, fn) {
      return this.on(ev, fn);
    }
  }, {
    key: 'on',
    value: function on(ev, fn) {
      try {
        return _get(MiniPass.prototype.__proto__ || Object.getPrototypeOf(MiniPass.prototype), 'on', this).call(this, ev, fn);
      } finally {
        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'end' && this[EMITTED_END]) {
          _get(MiniPass.prototype.__proto__ || Object.getPrototypeOf(MiniPass.prototype), 'emit', this).call(this, 'end');
          this.removeAllListeners('end');
        }
      }
    }
  }, {
    key: MAYBE_EMIT_END,
    value: function value() {
      if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {
        this.emit('end');
        this.emit('prefinish');
        this.emit('finish');
        if (this[CLOSED]) this.emit('close');
      }
    }
  }, {
    key: 'emit',
    value: function emit(ev, data) {
      var _this3 = this;

      if (ev === 'data') {
        if (!data) return;

        if (this.pipes.length) this.pipes.forEach(function (p) {
          return p.dest.write(data) || _this3.pause();
        });
      } else if (ev === 'end') {
        if (this[EMITTED_END] === true) return;

        this[EMITTED_END] = true;
        this.readable = false;

        if (this[DECODER]) {
          data = this[DECODER].end();
          if (data) {
            this.pipes.forEach(function (p) {
              return p.dest.write(data);
            });
            _get(MiniPass.prototype.__proto__ || Object.getPrototypeOf(MiniPass.prototype), 'emit', this).call(this, 'data', data);
          }
        }

        this.pipes.forEach(function (p) {
          p.dest.removeListener('drain', p.ondrain);
          if (!p.opts || p.opts.end !== false) p.dest.end();
        });
      } else if (ev === 'close') {
        this[CLOSED] = true;
        // don't emit close before 'end' and 'finish'
        if (!this[EMITTED_END]) return;
      }

      var args = new Array(arguments.length);
      args[0] = ev;
      args[1] = data;
      if (arguments.length > 2) {
        for (var i = 2; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
      }

      try {
        return _get(MiniPass.prototype.__proto__ || Object.getPrototypeOf(MiniPass.prototype), 'emit', this).apply(this, args);
      } finally {
        if (ev !== 'end') this[MAYBE_EMIT_END]();else this.removeAllListeners('end');
      }
    }

    // const all = await stream.collect()

  }, {
    key: 'collect',
    value: function collect() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var buf = [];
        _this4.on('data', function (c) {
          return buf.push(c);
        });
        _this4.on('end', function () {
          return resolve(buf);
        });
        _this4.on('error', reject);
      });
    }

    // for await (let chunk of stream)

  }, {
    key: ASYNCITERATOR,
    value: function value() {
      var _this5 = this;

      var next = function next() {
        var res = _this5.read();
        if (res !== null) return Promise.resolve({ done: false, value: res });

        if (_this5[EOF]) return Promise.resolve({ done: true });

        var resolve = null;
        var reject = null;
        var onerr = function onerr(er) {
          _this5.removeListener('data', ondata);
          _this5.removeListener('end', onend);
          reject(er);
        };
        var ondata = function ondata(value) {
          _this5.removeListener('error', onerr);
          _this5.removeListener('end', onend);
          _this5.pause();
          resolve({ value: value, done: !!_this5[EOF] });
        };
        var onend = function onend() {
          _this5.removeListener('error', onerr);
          _this5.removeListener('data', ondata);
          resolve({ done: true });
        };
        return new Promise(function (res, rej) {
          reject = rej;
          resolve = res;
          _this5.once('error', onerr);
          _this5.once('end', onend);
          _this5.once('data', ondata);
        });
      };

      return { next: next };
    }

    // for (let chunk of stream)

  }, {
    key: ITERATOR,
    value: function value() {
      var _this6 = this;

      var next = function next() {
        var value = _this6.read();
        var done = value === null;
        return { value: value, done: done };
      };
      return { next: next };
    }
  }, {
    key: 'bufferLength',
    get: function get() {
      return this[BUFFERLENGTH];
    }
  }, {
    key: 'encoding',
    get: function get() {
      return this[ENCODING];
    },
    set: function set(enc) {
      var _this7 = this;

      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');

      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');

      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {
          return _this7[DECODER].write(chunk);
        });
      }

      this[ENCODING] = enc;
    }
  }, {
    key: 'flowing',
    get: function get() {
      return this[FLOWING];
    }
  }, {
    key: 'emittedEnd',
    get: function get() {
      return this[EMITTED_END];
    }
  }]);

  return MiniPass;
}(EE);