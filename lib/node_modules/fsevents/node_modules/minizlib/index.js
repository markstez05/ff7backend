'use strict';

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var assert = require('assert');
var Buffer = require('buffer').Buffer;
var realZlib = require('zlib');

var constants = exports.constants = require('./constants.js');
var MiniPass = require('minipass');

var OriginalBufferConcat = Buffer.concat;

var ZlibError = function (_Error) {
  _inherits(ZlibError, _Error);

  function ZlibError(msg, errno) {
    _classCallCheck(this, ZlibError);

    var _this = _possibleConstructorReturn(this, (ZlibError.__proto__ || Object.getPrototypeOf(ZlibError)).call(this, 'zlib: ' + msg));

    _this.errno = errno;
    _this.code = codes.get(errno);
    return _this;
  }

  _createClass(ZlibError, [{
    key: 'name',
    get: function get() {
      return 'ZlibError';
    }
  }]);

  return ZlibError;
}(Error);

// translation table for return codes.


var codes = new Map([[constants.Z_OK, 'Z_OK'], [constants.Z_STREAM_END, 'Z_STREAM_END'], [constants.Z_NEED_DICT, 'Z_NEED_DICT'], [constants.Z_ERRNO, 'Z_ERRNO'], [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'], [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'], [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'], [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'], [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']]);

var validFlushFlags = new Set([constants.Z_NO_FLUSH, constants.Z_PARTIAL_FLUSH, constants.Z_SYNC_FLUSH, constants.Z_FULL_FLUSH, constants.Z_FINISH, constants.Z_BLOCK]);

var strategies = new Set([constants.Z_FILTERED, constants.Z_HUFFMAN_ONLY, constants.Z_RLE, constants.Z_FIXED, constants.Z_DEFAULT_STRATEGY]);

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
var _opts = Symbol('opts');
var _flushFlag = Symbol('flushFlag');
var _finishFlush = Symbol('finishFlush');
var _handle = Symbol('handle');
var _onError = Symbol('onError');
var _level = Symbol('level');
var _strategy = Symbol('strategy');
var _ended = Symbol('ended');

var Zlib = function (_MiniPass) {
  _inherits(Zlib, _MiniPass);

  function Zlib(opts, mode) {
    _classCallCheck(this, Zlib);

    var _this2 = _possibleConstructorReturn(this, (Zlib.__proto__ || Object.getPrototypeOf(Zlib)).call(this, opts));

    _this2[_ended] = false;
    _this2[_opts] = opts = opts || {};
    if (opts.flush && !validFlushFlags.has(opts.flush)) {
      throw new TypeError('Invalid flush flag: ' + opts.flush);
    }
    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {
      throw new TypeError('Invalid flush flag: ' + opts.finishFlush);
    }

    _this2[_flushFlag] = opts.flush || constants.Z_NO_FLUSH;
    _this2[_finishFlush] = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : constants.Z_FINISH;

    if (opts.chunkSize) {
      if (opts.chunkSize < constants.Z_MIN_CHUNK) {
        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);
      }
    }

    if (opts.windowBits) {
      if (opts.windowBits < constants.Z_MIN_WINDOWBITS || opts.windowBits > constants.Z_MAX_WINDOWBITS) {
        throw new RangeError('Invalid windowBits: ' + opts.windowBits);
      }
    }

    if (opts.level) {
      if (opts.level < constants.Z_MIN_LEVEL || opts.level > constants.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + opts.level);
      }
    }

    if (opts.memLevel) {
      if (opts.memLevel < constants.Z_MIN_MEMLEVEL || opts.memLevel > constants.Z_MAX_MEMLEVEL) {
        throw new RangeError('Invalid memLevel: ' + opts.memLevel);
      }
    }

    if (opts.strategy && !strategies.has(opts.strategy)) throw new TypeError('Invalid strategy: ' + opts.strategy);

    if (opts.dictionary) {
      if (!(opts.dictionary instanceof Buffer)) {
        throw new TypeError('Invalid dictionary: it should be a Buffer instance');
      }
    }

    _this2[_handle] = new realZlib[mode](opts);

    _this2[_onError] = function (err) {
      // there is no way to cleanly recover.
      // continuing only obscures problems.
      _this2.close();

      var error = new ZlibError(err.message, err.errno);
      _this2.emit('error', error);
    };
    _this2[_handle].on('error', _this2[_onError]);

    var level = typeof opts.level === 'number' ? opts.level : constants.Z_DEFAULT_COMPRESSION;

    var strategy = typeof opts.strategy === 'number' ? opts.strategy : constants.Z_DEFAULT_STRATEGY;

    // API changed in node v9
    /* istanbul ignore next */

    _this2[_level] = level;
    _this2[_strategy] = strategy;

    _this2.once('end', _this2.close);
    return _this2;
  }

  _createClass(Zlib, [{
    key: 'close',
    value: function close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit('close');
      }
    }
  }, {
    key: 'params',
    value: function params(level, strategy) {
      var _this3 = this;

      if (!this[_handle]) throw new Error('cannot switch params when binding is closed');

      // no way to test this without also not supporting params at all
      /* istanbul ignore if */
      if (!this[_handle].params) throw new Error('not supported in this implementation');

      if (level < constants.Z_MIN_LEVEL || level > constants.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level);
      }

      if (!strategies.has(strategy)) throw new TypeError('Invalid strategy: ' + strategy);

      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], 'zlib binding closed');
        // .params() calls .flush(), but the latter is always async in the
        // core zlib. We override .flush() temporarily to intercept that and
        // flush synchronously.
        var origFlush = this[_handle].flush;
        this[_handle].flush = function (flushFlag, cb) {
          _this3[_handle].flush = origFlush;
          _this3.flush(flushFlag);
          cb();
        };
        this[_handle].params(level, strategy);
        /* istanbul ignore else */
        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      assert(this[_handle], 'zlib binding closed');
      return this[_handle].reset();
    }
  }, {
    key: 'flush',
    value: function flush(kind) {
      if (kind === undefined) kind = constants.Z_FULL_FLUSH;

      if (this.ended) return;

      var flushFlag = this[_flushFlag];
      this[_flushFlag] = kind;
      this.write(Buffer.alloc(0));
      this[_flushFlag] = flushFlag;
    }
  }, {
    key: 'end',
    value: function end(chunk, encoding, cb) {
      if (chunk) this.write(chunk, encoding);
      this.flush(this[_finishFlush]);
      this[_ended] = true;
      return _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'end', this).call(this, null, null, cb);
    }
  }, {
    key: 'write',
    value: function write(chunk, encoding, cb) {
      // process the chunk using the sync process
      // then super.write() all the outputted chunks
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';

      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);

      assert(this[_handle], 'zlib binding closed');

      // _processChunk tries to .close() the native handle after it's done, so we
      // intercept that by temporarily making it a no-op.
      var nativeHandle = this[_handle]._handle;
      var originalNativeClose = nativeHandle.close;
      nativeHandle.close = function () {};
      var originalClose = this[_handle].close;
      this[_handle].close = function () {};
      // It also calls `Buffer.concat()` at the end, which may be convenient
      // for some, but which we are not interested in as it slows us down.
      Buffer.concat = function (args) {
        return args;
      };
      var result = void 0;
      try {
        result = this[_handle]._processChunk(chunk, this[_flushFlag]);
      } catch (err) {
        this[_onError](err);
      } finally {
        Buffer.concat = OriginalBufferConcat;
        if (this[_handle]) {
          // Core zlib resets `_handle` to null after attempting to close the
          // native handle. Our no-op handler prevented actual closure, but we
          // need to restore the `._handle` property.
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose;
          // `_processChunk()` adds an 'error' listener. If we don't remove it
          // after each call, these handlers start piling up.
          this[_handle].removeAllListeners('error');
        }
      }

      var writeReturn = void 0;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          // The first buffer is always `handle._outBuffer`, which would be
          // re-used for later invocations; so, we always have to copy that one.
          writeReturn = _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'write', this).call(this, Buffer.from(result[0]));
          for (var i = 1; i < result.length; i++) {
            writeReturn = _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'write', this).call(this, result[i]);
          }
        } else {
          writeReturn = _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'write', this).call(this, Buffer.from(result));
        }
      }

      if (cb) cb();
      return writeReturn;
    }
  }, {
    key: 'ended',
    get: function get() {
      return this[_ended];
    }
  }]);

  return Zlib;
}(MiniPass);

// minimal 2-byte header


var Deflate = function (_Zlib) {
  _inherits(Deflate, _Zlib);

  function Deflate(opts) {
    _classCallCheck(this, Deflate);

    return _possibleConstructorReturn(this, (Deflate.__proto__ || Object.getPrototypeOf(Deflate)).call(this, opts, 'Deflate'));
  }

  return Deflate;
}(Zlib);

var Inflate = function (_Zlib2) {
  _inherits(Inflate, _Zlib2);

  function Inflate(opts) {
    _classCallCheck(this, Inflate);

    return _possibleConstructorReturn(this, (Inflate.__proto__ || Object.getPrototypeOf(Inflate)).call(this, opts, 'Inflate'));
  }

  return Inflate;
}(Zlib);

// gzip - bigger header, same deflate compression


var Gzip = function (_Zlib3) {
  _inherits(Gzip, _Zlib3);

  function Gzip(opts) {
    _classCallCheck(this, Gzip);

    return _possibleConstructorReturn(this, (Gzip.__proto__ || Object.getPrototypeOf(Gzip)).call(this, opts, 'Gzip'));
  }

  return Gzip;
}(Zlib);

var Gunzip = function (_Zlib4) {
  _inherits(Gunzip, _Zlib4);

  function Gunzip(opts) {
    _classCallCheck(this, Gunzip);

    return _possibleConstructorReturn(this, (Gunzip.__proto__ || Object.getPrototypeOf(Gunzip)).call(this, opts, 'Gunzip'));
  }

  return Gunzip;
}(Zlib);

// raw - no header


var DeflateRaw = function (_Zlib5) {
  _inherits(DeflateRaw, _Zlib5);

  function DeflateRaw(opts) {
    _classCallCheck(this, DeflateRaw);

    return _possibleConstructorReturn(this, (DeflateRaw.__proto__ || Object.getPrototypeOf(DeflateRaw)).call(this, opts, 'DeflateRaw'));
  }

  return DeflateRaw;
}(Zlib);

var InflateRaw = function (_Zlib6) {
  _inherits(InflateRaw, _Zlib6);

  function InflateRaw(opts) {
    _classCallCheck(this, InflateRaw);

    return _possibleConstructorReturn(this, (InflateRaw.__proto__ || Object.getPrototypeOf(InflateRaw)).call(this, opts, 'InflateRaw'));
  }

  return InflateRaw;
}(Zlib);

// auto-detect header.


var Unzip = function (_Zlib7) {
  _inherits(Unzip, _Zlib7);

  function Unzip(opts) {
    _classCallCheck(this, Unzip);

    return _possibleConstructorReturn(this, (Unzip.__proto__ || Object.getPrototypeOf(Unzip)).call(this, opts, 'Unzip'));
  }

  return Unzip;
}(Zlib);

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;