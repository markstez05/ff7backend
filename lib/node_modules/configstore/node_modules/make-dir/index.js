'use strict';

var fs = require('fs');
var path = require('path');
var pify = require('pify');

var defaults = {
	mode: 511 & ~process.umask(),
	fs: fs
};

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
var checkPath = function checkPath(pth) {
	if (process.platform === 'win32') {
		var pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) {
			var err = new Error('Path contains invalid characters: ' + pth);
			err.code = 'EINVAL';
			throw err;
		}
	}
};

module.exports = function (input, opts) {
	return Promise.resolve().then(function () {
		checkPath(input);
		opts = Object.assign({}, defaults, opts);

		var mkdir = pify(opts.fs.mkdir);
		var stat = pify(opts.fs.stat);

		var make = function make(pth) {
			return mkdir(pth, opts.mode).then(function () {
				return pth;
			}).catch(function (err) {
				if (err.code === 'ENOENT') {
					if (err.message.includes('null bytes') || path.dirname(pth) === pth) {
						throw err;
					}

					return make(path.dirname(pth)).then(function () {
						return make(pth);
					});
				}

				return stat(pth).then(function (stats) {
					return stats.isDirectory() ? pth : Promise.reject();
				}).catch(function () {
					throw err;
				});
			});
		};

		return make(path.resolve(input));
	});
};

module.exports.sync = function (input, opts) {
	checkPath(input);
	opts = Object.assign({}, defaults, opts);

	var make = function make(pth) {
		try {
			opts.fs.mkdirSync(pth, opts.mode);
		} catch (err) {
			if (err.code === 'ENOENT') {
				if (err.message.includes('null bytes') || path.dirname(pth) === pth) {
					throw err;
				}

				make(path.dirname(pth));
				return make(pth);
			}

			try {
				if (!opts.fs.statSync(pth).isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw err;
			}
		}

		return pth;
	};

	return make(path.resolve(input));
};