'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');
var os = require('os');
var fs = require('graceful-fs');
var makeDir = require('make-dir');
var xdgBasedir = require('xdg-basedir');
var writeFileAtomic = require('write-file-atomic');
var dotProp = require('dot-prop');
var uniqueString = require('unique-string');

var configDir = xdgBasedir.config || path.join(os.tmpdir(), uniqueString());
var permissionError = 'You don\'t have access to this file.';
var makeDirOptions = { mode: 448 };
var writeFileOptions = { mode: 384 };

var Configstore = function () {
	function Configstore(id, defaults, opts) {
		_classCallCheck(this, Configstore);

		opts = opts || {};

		var pathPrefix = opts.globalConfigPath ? path.join(id, 'config.json') : path.join('configstore', id + '.json');

		this.path = path.join(configDir, pathPrefix);
		this.all = Object.assign({}, defaults, this.all);
	}

	_createClass(Configstore, [{
		key: 'get',
		value: function get(key) {
			return dotProp.get(this.all, key);
		}
	}, {
		key: 'set',
		value: function set(key, val) {
			var config = this.all;

			if (arguments.length === 1) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = Object.keys(key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var k = _step.value;

						dotProp.set(config, k, key[k]);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			} else {
				dotProp.set(config, key, val);
			}

			this.all = config;
		}
	}, {
		key: 'has',
		value: function has(key) {
			return dotProp.has(this.all, key);
		}
	}, {
		key: 'delete',
		value: function _delete(key) {
			var config = this.all;
			dotProp.delete(config, key);
			this.all = config;
		}
	}, {
		key: 'clear',
		value: function clear() {
			this.all = {};
		}
	}, {
		key: 'all',
		get: function get() {
			try {
				return JSON.parse(fs.readFileSync(this.path, 'utf8'));
			} catch (err) {
				// Create dir if it doesn't exist
				if (err.code === 'ENOENT') {
					makeDir.sync(path.dirname(this.path), makeDirOptions);
					return {};
				}

				// Improve the message of permission errors
				if (err.code === 'EACCES') {
					err.message = err.message + '\n' + permissionError + '\n';
				}

				// Empty the file if it encounters invalid JSON
				if (err.name === 'SyntaxError') {
					writeFileAtomic.sync(this.path, '', writeFileOptions);
					return {};
				}

				throw err;
			}
		},
		set: function set(val) {
			try {
				// Make sure the folder exists as it could have been deleted in the meantime
				makeDir.sync(path.dirname(this.path), makeDirOptions);

				writeFileAtomic.sync(this.path, JSON.stringify(val, null, '\t'), writeFileOptions);
			} catch (err) {
				// Improve the message of permission errors
				if (err.code === 'EACCES') {
					err.message = err.message + '\n' + permissionError + '\n';
				}

				throw err;
			}
		}
	}, {
		key: 'size',
		get: function get() {
			return Object.keys(this.all || {}).length;
		}
	}]);

	return Configstore;
}();

module.exports = Configstore;