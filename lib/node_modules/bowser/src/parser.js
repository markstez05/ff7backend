'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parserBrowsers = require('./parser-browsers.js');

var _parserBrowsers2 = _interopRequireDefault(_parserBrowsers);

var _parserOs = require('./parser-os.js');

var _parserOs2 = _interopRequireDefault(_parserOs);

var _parserPlatforms = require('./parser-platforms.js');

var _parserPlatforms2 = _interopRequireDefault(_parserPlatforms);

var _parserEngines = require('./parser-engines.js');

var _parserEngines2 = _interopRequireDefault(_parserEngines);

var _utils = require('./utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The main class that arranges the whole parsing process.
 */
var Parser = function () {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  function Parser(UA) {
    var skipParsing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, Parser);

    if (UA === void 0 || UA === null || UA === '') {
      throw new Error("UserAgent parameter can't be empty");
    }

    this._ua = UA;

    /**
     * @typedef ParsedResult
     * @property {Object} browser
     * @property {String|undefined} [browser.name]
     * Browser name, like `"Chrome"` or `"Internet Explorer"`
     * @property {String|undefined} [browser.version] Browser version as a String `"12.01.45334.10"`
     * @property {Object} os
     * @property {String|undefined} [os.name] OS name, like `"Windows"` or `"macOS"`
     * @property {String|undefined} [os.version] OS version, like `"NT 5.1"` or `"10.11.1"`
     * @property {String|undefined} [os.versionName] OS name, like `"XP"` or `"High Sierra"`
     * @property {Object} platform
     * @property {String|undefined} [platform.type]
     * platform type, can be either `"desktop"`, `"tablet"` or `"mobile"`
     * @property {String|undefined} [platform.vendor] Vendor of the device,
     * like `"Apple"` or `"Samsung"`
     * @property {String|undefined} [platform.model] Device model,
     * like `"iPhone"` or `"Kindle Fire HD 7"`
     * @property {Object} engine
     * @property {String|undefined} [engine.name]
     * Can be any of this: `WebKit`, `Blink`, `Gecko`, `Trident`, `Presto`, `EdgeHTML`
     * @property {String|undefined} [engine.version] String version of the engine
     */
    this.parsedResult = {};

    if (skipParsing !== true) {
      this.parse();
    }
  }

  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */


  _createClass(Parser, [{
    key: 'getUA',
    value: function getUA() {
      return this._ua;
    }

    /**
     * Test a UA string for a regexp
     * @param {RegExp} regex
     * @return {Boolean}
     */

  }, {
    key: 'test',
    value: function test(regex) {
      return regex.test(this._ua);
    }

    /**
     * Get parsed browser object
     * @return {Object}
     */

  }, {
    key: 'parseBrowser',
    value: function parseBrowser() {
      var _this = this;

      this.parsedResult.browser = {};

      var browserDescriptor = _parserBrowsers2.default.find(function (_browser) {
        if (typeof _browser.test === 'function') {
          return _browser.test(_this);
        }

        if (_browser.test instanceof Array) {
          return _browser.test.some(function (condition) {
            return _this.test(condition);
          });
        }

        throw new Error("Browser's test function is not valid");
      });

      if (browserDescriptor) {
        this.parsedResult.browser = browserDescriptor.describe(this.getUA());
      }

      return this.parsedResult.browser;
    }

    /**
     * Get parsed browser object
     * @return {Object}
     *
     * @public
     */

  }, {
    key: 'getBrowser',
    value: function getBrowser() {
      if (this.parsedResult.browser) {
        return this.parsedResult.browser;
      }

      return this.parseBrowser();
    }

    /**
     * Get browser's name
     * @return {String} Browser's name or an empty string
     *
     * @public
     */

  }, {
    key: 'getBrowserName',
    value: function getBrowserName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getBrowser().name).toLowerCase() || '';
      }
      return this.getBrowser().name || '';
    }

    /**
     * Get browser's version
     * @return {String} version of browser
     *
     * @public
     */

  }, {
    key: 'getBrowserVersion',
    value: function getBrowserVersion() {
      return this.getBrowser().version;
    }

    /**
     * Get OS
     * @return {Object}
     *
     * @example
     * this.getOS();
     * {
     *   name: 'macOS',
     *   version: '10.11.12'
     * }
     */

  }, {
    key: 'getOS',
    value: function getOS() {
      if (this.parsedResult.os) {
        return this.parsedResult.os;
      }

      return this.parseOS();
    }

    /**
     * Parse OS and save it to this.parsedResult.os
     * @return {*|{}}
     */

  }, {
    key: 'parseOS',
    value: function parseOS() {
      var _this2 = this;

      this.parsedResult.os = {};

      var os = _parserOs2.default.find(function (_os) {
        if (typeof _os.test === 'function') {
          return _os.test(_this2);
        }

        if (_os.test instanceof Array) {
          return _os.test.some(function (condition) {
            return _this2.test(condition);
          });
        }

        throw new Error("Browser's test function is not valid");
      });

      if (os) {
        this.parsedResult.os = os.describe(this.getUA());
      }

      return this.parsedResult.os;
    }

    /**
     * Get OS name
     * @param {Boolean} [toLowerCase] return lower-cased value
     * @return {String} name of the OS â€” macOS, Windows, Linux, etc.
     */

  }, {
    key: 'getOSName',
    value: function getOSName(toLowerCase) {
      var _getOS = this.getOS(),
          name = _getOS.name;

      if (toLowerCase) {
        return String(name).toLowerCase() || '';
      }

      return name || '';
    }

    /**
     * Get OS version
     * @return {String} full version with dots ('10.11.12', '5.6', etc)
     */

  }, {
    key: 'getOSVersion',
    value: function getOSVersion() {
      return this.getOS().version;
    }

    /**
     * Get parsed platform
     * @return {{}}
     */

  }, {
    key: 'getPlatform',
    value: function getPlatform() {
      if (this.parsedResult.platform) {
        return this.parsedResult.platform;
      }

      return this.parsePlatform();
    }

    /**
     * Get platform name
     * @param {Boolean} [toLowerCase=false]
     * @return {*}
     */

  }, {
    key: 'getPlatformType',
    value: function getPlatformType() {
      var toLowerCase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var _getPlatform = this.getPlatform(),
          type = _getPlatform.type;

      if (toLowerCase) {
        return String(type).toLowerCase() || '';
      }

      return type || '';
    }

    /**
     * Get parsed platform
     * @return {{}}
     */

  }, {
    key: 'parsePlatform',
    value: function parsePlatform() {
      var _this3 = this;

      this.parsedResult.platform = {};

      var platform = _parserPlatforms2.default.find(function (_platform) {
        if (typeof _platform.test === 'function') {
          return _platform.test(_this3);
        }

        if (_platform.test instanceof Array) {
          return _platform.test.some(function (condition) {
            return _this3.test(condition);
          });
        }

        throw new Error("Browser's test function is not valid");
      });

      if (platform) {
        this.parsedResult.platform = platform.describe(this.getUA());
      }

      return this.parsedResult.platform;
    }

    /**
     * Get parsed engine
     * @return {{}}
     */

  }, {
    key: 'getEngine',
    value: function getEngine() {
      if (this.parsedResult.engine) {
        return this.parsedResult.engine;
      }

      return this.parseEngine();
    }

    /**
     * Get engines's name
     * @return {String} Engines's name or an empty string
     *
     * @public
     */

  }, {
    key: 'getEngineName',
    value: function getEngineName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getEngine().name).toLowerCase() || '';
      }
      return this.getEngine().name || '';
    }

    /**
     * Get parsed platform
     * @return {{}}
     */

  }, {
    key: 'parseEngine',
    value: function parseEngine() {
      var _this4 = this;

      this.parsedResult.engine = {};

      var engine = _parserEngines2.default.find(function (_engine) {
        if (typeof _engine.test === 'function') {
          return _engine.test(_this4);
        }

        if (_engine.test instanceof Array) {
          return _engine.test.some(function (condition) {
            return _this4.test(condition);
          });
        }

        throw new Error("Browser's test function is not valid");
      });

      if (engine) {
        this.parsedResult.engine = engine.describe(this.getUA());
      }

      return this.parsedResult.engine;
    }

    /**
     * Parse full information about the browser
     */

  }, {
    key: 'parse',
    value: function parse() {
      this.parseBrowser();
      this.parseOS();
      this.parsePlatform();
      this.parseEngine();

      return this;
    }

    /**
     * Get parsed result
     * @return {ParsedResult}
     */

  }, {
    key: 'getResult',
    value: function getResult() {
      return Object.assign({}, this.parsedResult);
    }

    /**
     * Check if parsed browser matches certain conditions
     *
     * @param {Object} checkTree It's one or two layered object,
     * which can include a platform or an OS on the first layer
     * and should have browsers specs on the bottom-laying layer
     *
     * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
     * Returns `undefined` when the browser is no described in the checkTree object.
     *
     * @example
     * const browser = Bowser.getParser(window.navigator.userAgent);
     * if (browser.satisfies({chrome: '>118.01.1322' }))
     * // or with os
     * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
     * // or with platforms
     * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
     */

  }, {
    key: 'satisfies',
    value: function satisfies(checkTree) {
      var _this5 = this;

      var platformsAndOSes = {};
      var platformsAndOSCounter = 0;
      var browsers = {};
      var browsersCounter = 0;

      var allDefinitions = Object.keys(checkTree);

      allDefinitions.forEach(function (key) {
        var currentDefinition = checkTree[key];
        if (typeof currentDefinition === 'string') {
          browsers[key] = currentDefinition;
          browsersCounter += 1;
        } else if ((typeof currentDefinition === 'undefined' ? 'undefined' : _typeof(currentDefinition)) === 'object') {
          platformsAndOSes[key] = currentDefinition;
          platformsAndOSCounter += 1;
        }
      });

      if (platformsAndOSCounter > 0) {
        var platformsAndOSNames = Object.keys(platformsAndOSes);
        var OSMatchingDefinition = platformsAndOSNames.find(function (name) {
          return _this5.isOS(name);
        });

        if (OSMatchingDefinition) {
          var osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);

          if (osResult !== void 0) {
            return osResult;
          }
        }

        var platformMatchingDefinition = platformsAndOSNames.find(function (name) {
          return _this5.isPlatform(name);
        });
        if (platformMatchingDefinition) {
          var platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);

          if (platformResult !== void 0) {
            return platformResult;
          }
        }
      }

      if (browsersCounter > 0) {
        var browserNames = Object.keys(browsers);
        var matchingDefinition = browserNames.find(function (name) {
          return _this5.isBrowser(name, true);
        });

        if (matchingDefinition !== void 0) {
          return this.compareVersion(browsers[matchingDefinition]);
        }
      }

      return undefined;
    }

    /**
     * Check if the browser name equals the passed string
     * @param browserName The string to compare with the browser name
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {boolean}
     */

  }, {
    key: 'isBrowser',
    value: function isBrowser(browserName) {
      var includingAlias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var defaultBrowserName = this.getBrowserName().toLowerCase();
      var browserNameLower = browserName.toLowerCase();
      var alias = _utils2.default.getBrowserTypeByAlias(browserNameLower);

      if (includingAlias && alias) {
        browserNameLower = alias.toLowerCase();
      }
      return browserNameLower === defaultBrowserName;
    }
  }, {
    key: 'compareVersion',
    value: function compareVersion(version) {
      var expectedResults = [0];
      var comparableVersion = version;
      var isLoose = false;

      var currentBrowserVersion = this.getBrowserVersion();

      if (typeof currentBrowserVersion !== 'string') {
        return void 0;
      }

      if (version[0] === '>' || version[0] === '<') {
        comparableVersion = version.substr(1);
        if (version[1] === '=') {
          isLoose = true;
          comparableVersion = version.substr(2);
        } else {
          expectedResults = [];
        }
        if (version[0] === '>') {
          expectedResults.push(1);
        } else {
          expectedResults.push(-1);
        }
      } else if (version[0] === '=') {
        comparableVersion = version.substr(1);
      } else if (version[0] === '~') {
        isLoose = true;
        comparableVersion = version.substr(1);
      }

      return expectedResults.indexOf(_utils2.default.compareVersions(currentBrowserVersion, comparableVersion, isLoose)) > -1;
    }
  }, {
    key: 'isOS',
    value: function isOS(osName) {
      return this.getOSName(true) === String(osName).toLowerCase();
    }
  }, {
    key: 'isPlatform',
    value: function isPlatform(platformType) {
      return this.getPlatformType(true) === String(platformType).toLowerCase();
    }
  }, {
    key: 'isEngine',
    value: function isEngine(engineName) {
      return this.getEngineName(true) === String(engineName).toLowerCase();
    }

    /**
     * Is anything? Check if the browser is called "anything",
     * the OS called "anything" or the platform called "anything"
     * @param {String} anything
     * @returns {Boolean}
     */

  }, {
    key: 'is',
    value: function is(anything) {
      return this.isBrowser(anything) || this.isOS(anything) || this.isPlatform(anything);
    }

    /**
     * Check if any of the given values satisfies this.is(anything)
     * @param {String[]} anythings
     * @returns {Boolean}
     */

  }, {
    key: 'some',
    value: function some() {
      var _this6 = this;

      var anythings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return anythings.some(function (anything) {
        return _this6.is(anything);
      });
    }
  }]);

  return Parser;
}();

exports.default = Parser;